// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/tetration_network_policy.proto

/*
Package TetrationNetworkPolicyProto is a generated protocol buffer package.

It is generated from these files:
	proto/tetration_network_policy.proto

It has these top-level messages:
	AddressWithPrefix
	AddressWithRange
	LBService
	KeyValue
	InventoryItem
	InventoryGroupMetaData
	InventoryGroup
	PortRange
	ProtocolAndPorts
	FlowFilter
	IntentMetaData
	Intent
	CatchAllPolicy
	NetworkPolicy
	ScopeInfo
	TenantNetworkPolicy
	IntentStatus
	NetworkPolicyStatus
	AgentHealth
	TenantNetworkPolicyStatus
	KafkaUpdate
*/
package TetrationNetworkPolicyProto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IPAddressFamily int32

const (
	IPAddressFamily_INVALID IPAddressFamily = 0
	IPAddressFamily_IPv4    IPAddressFamily = 1
	IPAddressFamily_IPv6    IPAddressFamily = 2
)

var IPAddressFamily_name = map[int32]string{
	0: "INVALID",
	1: "IPv4",
	2: "IPv6",
}
var IPAddressFamily_value = map[string]int32{
	"INVALID": 0,
	"IPv4":    1,
	"IPv6":    2,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type IPProtocol int32

const (
	IPProtocol_IP             IPProtocol = 0
	IPProtocol_ICMP           IPProtocol = 1
	IPProtocol_IGMP           IPProtocol = 2
	IPProtocol_GGP            IPProtocol = 3
	IPProtocol_IPIP           IPProtocol = 4
	IPProtocol_ST             IPProtocol = 5
	IPProtocol_TCP            IPProtocol = 6
	IPProtocol_CBT            IPProtocol = 7
	IPProtocol_EGP            IPProtocol = 8
	IPProtocol_IGP            IPProtocol = 9
	IPProtocol_BBNRCC         IPProtocol = 10
	IPProtocol_NVP            IPProtocol = 11
	IPProtocol_PUP            IPProtocol = 12
	IPProtocol_ARGUS          IPProtocol = 13
	IPProtocol_EMCON          IPProtocol = 14
	IPProtocol_XNET           IPProtocol = 15
	IPProtocol_CHAOS          IPProtocol = 16
	IPProtocol_UDP            IPProtocol = 17
	IPProtocol_MUX            IPProtocol = 18
	IPProtocol_DCNMEAS        IPProtocol = 19
	IPProtocol_HMP            IPProtocol = 20
	IPProtocol_PRM            IPProtocol = 21
	IPProtocol_IDP            IPProtocol = 22
	IPProtocol_TRUNK1         IPProtocol = 23
	IPProtocol_TRUNK2         IPProtocol = 24
	IPProtocol_LEAF1          IPProtocol = 25
	IPProtocol_LEAF2          IPProtocol = 26
	IPProtocol_RDP            IPProtocol = 27
	IPProtocol_IRTP           IPProtocol = 28
	IPProtocol_TP             IPProtocol = 29
	IPProtocol_NETBLT         IPProtocol = 30
	IPProtocol_MFPNSP         IPProtocol = 31
	IPProtocol_MERITINP       IPProtocol = 32
	IPProtocol_SEP            IPProtocol = 33
	IPProtocol__3PC           IPProtocol = 34
	IPProtocol_IDPR           IPProtocol = 35
	IPProtocol_XTP            IPProtocol = 36
	IPProtocol_DDP            IPProtocol = 37
	IPProtocol_CMTP           IPProtocol = 38
	IPProtocol_TPPP           IPProtocol = 39
	IPProtocol_IL             IPProtocol = 40
	IPProtocol_IP6            IPProtocol = 41
	IPProtocol_SDRP           IPProtocol = 42
	IPProtocol_ROUTING        IPProtocol = 43
	IPProtocol_FRAGMENT       IPProtocol = 44
	IPProtocol_RSVP           IPProtocol = 46
	IPProtocol_GRE            IPProtocol = 47
	IPProtocol_MHRP           IPProtocol = 48
	IPProtocol_ENA            IPProtocol = 49
	IPProtocol_ESP            IPProtocol = 50
	IPProtocol_AH             IPProtocol = 51
	IPProtocol_INLSP          IPProtocol = 52
	IPProtocol_SWIPE          IPProtocol = 53
	IPProtocol_NARP           IPProtocol = 54
	IPProtocol_MOBILE         IPProtocol = 55
	IPProtocol_TLSP           IPProtocol = 56
	IPProtocol_SKIP           IPProtocol = 57
	IPProtocol_ICMP6          IPProtocol = 58
	IPProtocol_NONE           IPProtocol = 59
	IPProtocol_DSTOPTS        IPProtocol = 60
	IPProtocol_ANYHOST        IPProtocol = 61
	IPProtocol_CFTP           IPProtocol = 62
	IPProtocol_ANYNET         IPProtocol = 63
	IPProtocol_EXPAK          IPProtocol = 64
	IPProtocol_KRYPTOLAN      IPProtocol = 65
	IPProtocol_RVD            IPProtocol = 66
	IPProtocol_IPPC           IPProtocol = 67
	IPProtocol_DISTFS         IPProtocol = 68
	IPProtocol_SATMON         IPProtocol = 69
	IPProtocol_VISA           IPProtocol = 70
	IPProtocol_IPCV           IPProtocol = 71
	IPProtocol_CPNX           IPProtocol = 72
	IPProtocol_CPHB           IPProtocol = 73
	IPProtocol_WSN            IPProtocol = 74
	IPProtocol_PVP            IPProtocol = 75
	IPProtocol_BRSATMON       IPProtocol = 76
	IPProtocol_SUNND          IPProtocol = 77
	IPProtocol_WBMON          IPProtocol = 78
	IPProtocol_WBEXPAK        IPProtocol = 79
	IPProtocol_EON            IPProtocol = 80
	IPProtocol_VMTP           IPProtocol = 81
	IPProtocol_SVMTP          IPProtocol = 82
	IPProtocol_VINES          IPProtocol = 83
	IPProtocol_TTP            IPProtocol = 84
	IPProtocol_NSFIGP         IPProtocol = 85
	IPProtocol_DGP            IPProtocol = 86
	IPProtocol_TCF            IPProtocol = 87
	IPProtocol_EIGRP          IPProtocol = 88
	IPProtocol_OSPF           IPProtocol = 89
	IPProtocol_SPRITERPC      IPProtocol = 90
	IPProtocol_LARP           IPProtocol = 91
	IPProtocol_MTP            IPProtocol = 92
	IPProtocol_AX25           IPProtocol = 93
	IPProtocol_IPIPENCAP      IPProtocol = 94
	IPProtocol_MICP           IPProtocol = 95
	IPProtocol_SCCSP          IPProtocol = 96
	IPProtocol_ETHERIP        IPProtocol = 97
	IPProtocol_ENCAP          IPProtocol = 98
	IPProtocol_ANYENC         IPProtocol = 99
	IPProtocol_GMTP           IPProtocol = 100
	IPProtocol_IFMP           IPProtocol = 101
	IPProtocol_PNNI           IPProtocol = 102
	IPProtocol_PIM            IPProtocol = 103
	IPProtocol_ARIS           IPProtocol = 104
	IPProtocol_SCPS           IPProtocol = 105
	IPProtocol_QNX            IPProtocol = 106
	IPProtocol_AN             IPProtocol = 107
	IPProtocol_IPCOMP         IPProtocol = 108
	IPProtocol_SNP            IPProtocol = 109
	IPProtocol_COMPAQPEER     IPProtocol = 110
	IPProtocol_IPXIP          IPProtocol = 111
	IPProtocol_VRRP           IPProtocol = 112
	IPProtocol_PGM            IPProtocol = 113
	IPProtocol_ANY0HOP        IPProtocol = 114
	IPProtocol_L2TP           IPProtocol = 115
	IPProtocol_DDX            IPProtocol = 116
	IPProtocol_IATP           IPProtocol = 117
	IPProtocol_STP            IPProtocol = 118
	IPProtocol_SRP            IPProtocol = 119
	IPProtocol_UTI            IPProtocol = 120
	IPProtocol_SMP            IPProtocol = 121
	IPProtocol_SM             IPProtocol = 122
	IPProtocol_PTP            IPProtocol = 123
	IPProtocol_ISIS           IPProtocol = 124
	IPProtocol_FIRE           IPProtocol = 125
	IPProtocol_CRTP           IPProtocol = 126
	IPProtocol_CRUDP          IPProtocol = 127
	IPProtocol_SSCOPMCE       IPProtocol = 128
	IPProtocol_IPLT           IPProtocol = 129
	IPProtocol_SPS            IPProtocol = 130
	IPProtocol_PIPE           IPProtocol = 131
	IPProtocol_SCTP           IPProtocol = 132
	IPProtocol_FC             IPProtocol = 133
	IPProtocol_RSVPIGN        IPProtocol = 134
	IPProtocol_MOBILITYHEADER IPProtocol = 135
	IPProtocol_UDPLITE        IPProtocol = 136
	IPProtocol_MPLSINIP       IPProtocol = 137
	IPProtocol_MANET          IPProtocol = 138
	IPProtocol_HIP            IPProtocol = 139
	IPProtocol_SHIM6          IPProtocol = 140
	IPProtocol_WESP           IPProtocol = 141
	IPProtocol_ROHC           IPProtocol = 142
	IPProtocol_PROTO_143      IPProtocol = 143
	IPProtocol_PROTO_144      IPProtocol = 144
	IPProtocol_PROTO_145      IPProtocol = 145
	IPProtocol_PROTO_146      IPProtocol = 146
	IPProtocol_PROTO_147      IPProtocol = 147
	IPProtocol_PROTO_148      IPProtocol = 148
	IPProtocol_PROTO_149      IPProtocol = 149
	IPProtocol_PROTO_150      IPProtocol = 150
	IPProtocol_PROTO_151      IPProtocol = 151
	IPProtocol_PROTO_152      IPProtocol = 152
	IPProtocol_PROTO_153      IPProtocol = 153
	IPProtocol_PROTO_154      IPProtocol = 154
	IPProtocol_PROTO_155      IPProtocol = 155
	IPProtocol_PROTO_156      IPProtocol = 156
	IPProtocol_PROTO_157      IPProtocol = 157
	IPProtocol_PROTO_158      IPProtocol = 158
	IPProtocol_PROTO_159      IPProtocol = 159
	IPProtocol_PROTO_160      IPProtocol = 160
	IPProtocol_PROTO_161      IPProtocol = 161
	IPProtocol_PROTO_162      IPProtocol = 162
	IPProtocol_PROTO_163      IPProtocol = 163
	IPProtocol_PROTO_164      IPProtocol = 164
	IPProtocol_PROTO_165      IPProtocol = 165
	IPProtocol_PROTO_166      IPProtocol = 166
	IPProtocol_PROTO_167      IPProtocol = 167
	IPProtocol_PROTO_168      IPProtocol = 168
	IPProtocol_PROTO_169      IPProtocol = 169
	IPProtocol_PROTO_170      IPProtocol = 170
	IPProtocol_PROTO_171      IPProtocol = 171
	IPProtocol_PROTO_172      IPProtocol = 172
	IPProtocol_PROTO_173      IPProtocol = 173
	IPProtocol_PROTO_174      IPProtocol = 174
	IPProtocol_PROTO_175      IPProtocol = 175
	IPProtocol_PROTO_176      IPProtocol = 176
	IPProtocol_PROTO_177      IPProtocol = 177
	IPProtocol_PROTO_178      IPProtocol = 178
	IPProtocol_PROTO_179      IPProtocol = 179
	IPProtocol_PROTO_180      IPProtocol = 180
	IPProtocol_PROTO_181      IPProtocol = 181
	IPProtocol_PROTO_182      IPProtocol = 182
	IPProtocol_PROTO_183      IPProtocol = 183
	IPProtocol_PROTO_184      IPProtocol = 184
	IPProtocol_PROTO_185      IPProtocol = 185
	IPProtocol_PROTO_186      IPProtocol = 186
	IPProtocol_PROTO_187      IPProtocol = 187
	IPProtocol_PROTO_188      IPProtocol = 188
	IPProtocol_PROTO_189      IPProtocol = 189
	IPProtocol_PROTO_190      IPProtocol = 190
	IPProtocol_PROTO_191      IPProtocol = 191
	IPProtocol_PROTO_192      IPProtocol = 192
	IPProtocol_PROTO_193      IPProtocol = 193
	IPProtocol_PROTO_194      IPProtocol = 194
	IPProtocol_PROTO_195      IPProtocol = 195
	IPProtocol_PROTO_196      IPProtocol = 196
	IPProtocol_PROTO_197      IPProtocol = 197
	IPProtocol_PROTO_198      IPProtocol = 198
	IPProtocol_PROTO_199      IPProtocol = 199
	IPProtocol_PROTO_200      IPProtocol = 200
	IPProtocol_PROTO_201      IPProtocol = 201
	IPProtocol_PROTO_202      IPProtocol = 202
	IPProtocol_PROTO_203      IPProtocol = 203
	IPProtocol_PROTO_204      IPProtocol = 204
	IPProtocol_PROTO_205      IPProtocol = 205
	IPProtocol_PROTO_206      IPProtocol = 206
	IPProtocol_PROTO_207      IPProtocol = 207
	IPProtocol_PROTO_208      IPProtocol = 208
	IPProtocol_PROTO_209      IPProtocol = 209
	IPProtocol_PROTO_210      IPProtocol = 210
	IPProtocol_PROTO_211      IPProtocol = 211
	IPProtocol_PROTO_212      IPProtocol = 212
	IPProtocol_PROTO_213      IPProtocol = 213
	IPProtocol_PROTO_214      IPProtocol = 214
	IPProtocol_PROTO_215      IPProtocol = 215
	IPProtocol_PROTO_216      IPProtocol = 216
	IPProtocol_PROTO_217      IPProtocol = 217
	IPProtocol_PROTO_218      IPProtocol = 218
	IPProtocol_PROTO_219      IPProtocol = 219
	IPProtocol_PROTO_220      IPProtocol = 220
	IPProtocol_PROTO_221      IPProtocol = 221
	IPProtocol_PROTO_222      IPProtocol = 222
	IPProtocol_PROTO_223      IPProtocol = 223
	IPProtocol_PROTO_224      IPProtocol = 224
	IPProtocol_PROTO_225      IPProtocol = 225
	IPProtocol_PROTO_226      IPProtocol = 226
	IPProtocol_PROTO_227      IPProtocol = 227
	IPProtocol_PROTO_228      IPProtocol = 228
	IPProtocol_PROTO_229      IPProtocol = 229
	IPProtocol_PROTO_230      IPProtocol = 230
	IPProtocol_PROTO_231      IPProtocol = 231
	IPProtocol_PROTO_232      IPProtocol = 232
	IPProtocol_PROTO_233      IPProtocol = 233
	IPProtocol_PROTO_234      IPProtocol = 234
	IPProtocol_PROTO_235      IPProtocol = 235
	IPProtocol_PROTO_236      IPProtocol = 236
	IPProtocol_PROTO_237      IPProtocol = 237
	IPProtocol_PROTO_238      IPProtocol = 238
	IPProtocol_PROTO_239      IPProtocol = 239
	IPProtocol_PROTO_240      IPProtocol = 240
	IPProtocol_PROTO_241      IPProtocol = 241
	IPProtocol_PROTO_242      IPProtocol = 242
	IPProtocol_PROTO_243      IPProtocol = 243
	IPProtocol_PROTO_244      IPProtocol = 244
	IPProtocol_PROTO_245      IPProtocol = 245
	IPProtocol_PROTO_246      IPProtocol = 246
	IPProtocol_ARP_REVREQUEST IPProtocol = 247
	IPProtocol_ARP_REVREPLY   IPProtocol = 248
	IPProtocol_ARP_REQUEST    IPProtocol = 249
	IPProtocol_ARP_REPLY      IPProtocol = 250
	IPProtocol_PROTO_251      IPProtocol = 251
	IPProtocol_PROTO_252      IPProtocol = 252
	IPProtocol_EXPERIMENT1    IPProtocol = 253
	IPProtocol_EXPERIMENT2    IPProtocol = 254
	IPProtocol_RESERVED       IPProtocol = 255
)

var IPProtocol_name = map[int32]string{
	0:   "IP",
	1:   "ICMP",
	2:   "IGMP",
	3:   "GGP",
	4:   "IPIP",
	5:   "ST",
	6:   "TCP",
	7:   "CBT",
	8:   "EGP",
	9:   "IGP",
	10:  "BBNRCC",
	11:  "NVP",
	12:  "PUP",
	13:  "ARGUS",
	14:  "EMCON",
	15:  "XNET",
	16:  "CHAOS",
	17:  "UDP",
	18:  "MUX",
	19:  "DCNMEAS",
	20:  "HMP",
	21:  "PRM",
	22:  "IDP",
	23:  "TRUNK1",
	24:  "TRUNK2",
	25:  "LEAF1",
	26:  "LEAF2",
	27:  "RDP",
	28:  "IRTP",
	29:  "TP",
	30:  "NETBLT",
	31:  "MFPNSP",
	32:  "MERITINP",
	33:  "SEP",
	34:  "_3PC",
	35:  "IDPR",
	36:  "XTP",
	37:  "DDP",
	38:  "CMTP",
	39:  "TPPP",
	40:  "IL",
	41:  "IP6",
	42:  "SDRP",
	43:  "ROUTING",
	44:  "FRAGMENT",
	46:  "RSVP",
	47:  "GRE",
	48:  "MHRP",
	49:  "ENA",
	50:  "ESP",
	51:  "AH",
	52:  "INLSP",
	53:  "SWIPE",
	54:  "NARP",
	55:  "MOBILE",
	56:  "TLSP",
	57:  "SKIP",
	58:  "ICMP6",
	59:  "NONE",
	60:  "DSTOPTS",
	61:  "ANYHOST",
	62:  "CFTP",
	63:  "ANYNET",
	64:  "EXPAK",
	65:  "KRYPTOLAN",
	66:  "RVD",
	67:  "IPPC",
	68:  "DISTFS",
	69:  "SATMON",
	70:  "VISA",
	71:  "IPCV",
	72:  "CPNX",
	73:  "CPHB",
	74:  "WSN",
	75:  "PVP",
	76:  "BRSATMON",
	77:  "SUNND",
	78:  "WBMON",
	79:  "WBEXPAK",
	80:  "EON",
	81:  "VMTP",
	82:  "SVMTP",
	83:  "VINES",
	84:  "TTP",
	85:  "NSFIGP",
	86:  "DGP",
	87:  "TCF",
	88:  "EIGRP",
	89:  "OSPF",
	90:  "SPRITERPC",
	91:  "LARP",
	92:  "MTP",
	93:  "AX25",
	94:  "IPIPENCAP",
	95:  "MICP",
	96:  "SCCSP",
	97:  "ETHERIP",
	98:  "ENCAP",
	99:  "ANYENC",
	100: "GMTP",
	101: "IFMP",
	102: "PNNI",
	103: "PIM",
	104: "ARIS",
	105: "SCPS",
	106: "QNX",
	107: "AN",
	108: "IPCOMP",
	109: "SNP",
	110: "COMPAQPEER",
	111: "IPXIP",
	112: "VRRP",
	113: "PGM",
	114: "ANY0HOP",
	115: "L2TP",
	116: "DDX",
	117: "IATP",
	118: "STP",
	119: "SRP",
	120: "UTI",
	121: "SMP",
	122: "SM",
	123: "PTP",
	124: "ISIS",
	125: "FIRE",
	126: "CRTP",
	127: "CRUDP",
	128: "SSCOPMCE",
	129: "IPLT",
	130: "SPS",
	131: "PIPE",
	132: "SCTP",
	133: "FC",
	134: "RSVPIGN",
	135: "MOBILITYHEADER",
	136: "UDPLITE",
	137: "MPLSINIP",
	138: "MANET",
	139: "HIP",
	140: "SHIM6",
	141: "WESP",
	142: "ROHC",
	143: "PROTO_143",
	144: "PROTO_144",
	145: "PROTO_145",
	146: "PROTO_146",
	147: "PROTO_147",
	148: "PROTO_148",
	149: "PROTO_149",
	150: "PROTO_150",
	151: "PROTO_151",
	152: "PROTO_152",
	153: "PROTO_153",
	154: "PROTO_154",
	155: "PROTO_155",
	156: "PROTO_156",
	157: "PROTO_157",
	158: "PROTO_158",
	159: "PROTO_159",
	160: "PROTO_160",
	161: "PROTO_161",
	162: "PROTO_162",
	163: "PROTO_163",
	164: "PROTO_164",
	165: "PROTO_165",
	166: "PROTO_166",
	167: "PROTO_167",
	168: "PROTO_168",
	169: "PROTO_169",
	170: "PROTO_170",
	171: "PROTO_171",
	172: "PROTO_172",
	173: "PROTO_173",
	174: "PROTO_174",
	175: "PROTO_175",
	176: "PROTO_176",
	177: "PROTO_177",
	178: "PROTO_178",
	179: "PROTO_179",
	180: "PROTO_180",
	181: "PROTO_181",
	182: "PROTO_182",
	183: "PROTO_183",
	184: "PROTO_184",
	185: "PROTO_185",
	186: "PROTO_186",
	187: "PROTO_187",
	188: "PROTO_188",
	189: "PROTO_189",
	190: "PROTO_190",
	191: "PROTO_191",
	192: "PROTO_192",
	193: "PROTO_193",
	194: "PROTO_194",
	195: "PROTO_195",
	196: "PROTO_196",
	197: "PROTO_197",
	198: "PROTO_198",
	199: "PROTO_199",
	200: "PROTO_200",
	201: "PROTO_201",
	202: "PROTO_202",
	203: "PROTO_203",
	204: "PROTO_204",
	205: "PROTO_205",
	206: "PROTO_206",
	207: "PROTO_207",
	208: "PROTO_208",
	209: "PROTO_209",
	210: "PROTO_210",
	211: "PROTO_211",
	212: "PROTO_212",
	213: "PROTO_213",
	214: "PROTO_214",
	215: "PROTO_215",
	216: "PROTO_216",
	217: "PROTO_217",
	218: "PROTO_218",
	219: "PROTO_219",
	220: "PROTO_220",
	221: "PROTO_221",
	222: "PROTO_222",
	223: "PROTO_223",
	224: "PROTO_224",
	225: "PROTO_225",
	226: "PROTO_226",
	227: "PROTO_227",
	228: "PROTO_228",
	229: "PROTO_229",
	230: "PROTO_230",
	231: "PROTO_231",
	232: "PROTO_232",
	233: "PROTO_233",
	234: "PROTO_234",
	235: "PROTO_235",
	236: "PROTO_236",
	237: "PROTO_237",
	238: "PROTO_238",
	239: "PROTO_239",
	240: "PROTO_240",
	241: "PROTO_241",
	242: "PROTO_242",
	243: "PROTO_243",
	244: "PROTO_244",
	245: "PROTO_245",
	246: "PROTO_246",
	247: "ARP_REVREQUEST",
	248: "ARP_REVREPLY",
	249: "ARP_REQUEST",
	250: "ARP_REPLY",
	251: "PROTO_251",
	252: "PROTO_252",
	253: "EXPERIMENT1",
	254: "EXPERIMENT2",
	255: "RESERVED",
}
var IPProtocol_value = map[string]int32{
	"IP":             0,
	"ICMP":           1,
	"IGMP":           2,
	"GGP":            3,
	"IPIP":           4,
	"ST":             5,
	"TCP":            6,
	"CBT":            7,
	"EGP":            8,
	"IGP":            9,
	"BBNRCC":         10,
	"NVP":            11,
	"PUP":            12,
	"ARGUS":          13,
	"EMCON":          14,
	"XNET":           15,
	"CHAOS":          16,
	"UDP":            17,
	"MUX":            18,
	"DCNMEAS":        19,
	"HMP":            20,
	"PRM":            21,
	"IDP":            22,
	"TRUNK1":         23,
	"TRUNK2":         24,
	"LEAF1":          25,
	"LEAF2":          26,
	"RDP":            27,
	"IRTP":           28,
	"TP":             29,
	"NETBLT":         30,
	"MFPNSP":         31,
	"MERITINP":       32,
	"SEP":            33,
	"_3PC":           34,
	"IDPR":           35,
	"XTP":            36,
	"DDP":            37,
	"CMTP":           38,
	"TPPP":           39,
	"IL":             40,
	"IP6":            41,
	"SDRP":           42,
	"ROUTING":        43,
	"FRAGMENT":       44,
	"RSVP":           46,
	"GRE":            47,
	"MHRP":           48,
	"ENA":            49,
	"ESP":            50,
	"AH":             51,
	"INLSP":          52,
	"SWIPE":          53,
	"NARP":           54,
	"MOBILE":         55,
	"TLSP":           56,
	"SKIP":           57,
	"ICMP6":          58,
	"NONE":           59,
	"DSTOPTS":        60,
	"ANYHOST":        61,
	"CFTP":           62,
	"ANYNET":         63,
	"EXPAK":          64,
	"KRYPTOLAN":      65,
	"RVD":            66,
	"IPPC":           67,
	"DISTFS":         68,
	"SATMON":         69,
	"VISA":           70,
	"IPCV":           71,
	"CPNX":           72,
	"CPHB":           73,
	"WSN":            74,
	"PVP":            75,
	"BRSATMON":       76,
	"SUNND":          77,
	"WBMON":          78,
	"WBEXPAK":        79,
	"EON":            80,
	"VMTP":           81,
	"SVMTP":          82,
	"VINES":          83,
	"TTP":            84,
	"NSFIGP":         85,
	"DGP":            86,
	"TCF":            87,
	"EIGRP":          88,
	"OSPF":           89,
	"SPRITERPC":      90,
	"LARP":           91,
	"MTP":            92,
	"AX25":           93,
	"IPIPENCAP":      94,
	"MICP":           95,
	"SCCSP":          96,
	"ETHERIP":        97,
	"ENCAP":          98,
	"ANYENC":         99,
	"GMTP":           100,
	"IFMP":           101,
	"PNNI":           102,
	"PIM":            103,
	"ARIS":           104,
	"SCPS":           105,
	"QNX":            106,
	"AN":             107,
	"IPCOMP":         108,
	"SNP":            109,
	"COMPAQPEER":     110,
	"IPXIP":          111,
	"VRRP":           112,
	"PGM":            113,
	"ANY0HOP":        114,
	"L2TP":           115,
	"DDX":            116,
	"IATP":           117,
	"STP":            118,
	"SRP":            119,
	"UTI":            120,
	"SMP":            121,
	"SM":             122,
	"PTP":            123,
	"ISIS":           124,
	"FIRE":           125,
	"CRTP":           126,
	"CRUDP":          127,
	"SSCOPMCE":       128,
	"IPLT":           129,
	"SPS":            130,
	"PIPE":           131,
	"SCTP":           132,
	"FC":             133,
	"RSVPIGN":        134,
	"MOBILITYHEADER": 135,
	"UDPLITE":        136,
	"MPLSINIP":       137,
	"MANET":          138,
	"HIP":            139,
	"SHIM6":          140,
	"WESP":           141,
	"ROHC":           142,
	"PROTO_143":      143,
	"PROTO_144":      144,
	"PROTO_145":      145,
	"PROTO_146":      146,
	"PROTO_147":      147,
	"PROTO_148":      148,
	"PROTO_149":      149,
	"PROTO_150":      150,
	"PROTO_151":      151,
	"PROTO_152":      152,
	"PROTO_153":      153,
	"PROTO_154":      154,
	"PROTO_155":      155,
	"PROTO_156":      156,
	"PROTO_157":      157,
	"PROTO_158":      158,
	"PROTO_159":      159,
	"PROTO_160":      160,
	"PROTO_161":      161,
	"PROTO_162":      162,
	"PROTO_163":      163,
	"PROTO_164":      164,
	"PROTO_165":      165,
	"PROTO_166":      166,
	"PROTO_167":      167,
	"PROTO_168":      168,
	"PROTO_169":      169,
	"PROTO_170":      170,
	"PROTO_171":      171,
	"PROTO_172":      172,
	"PROTO_173":      173,
	"PROTO_174":      174,
	"PROTO_175":      175,
	"PROTO_176":      176,
	"PROTO_177":      177,
	"PROTO_178":      178,
	"PROTO_179":      179,
	"PROTO_180":      180,
	"PROTO_181":      181,
	"PROTO_182":      182,
	"PROTO_183":      183,
	"PROTO_184":      184,
	"PROTO_185":      185,
	"PROTO_186":      186,
	"PROTO_187":      187,
	"PROTO_188":      188,
	"PROTO_189":      189,
	"PROTO_190":      190,
	"PROTO_191":      191,
	"PROTO_192":      192,
	"PROTO_193":      193,
	"PROTO_194":      194,
	"PROTO_195":      195,
	"PROTO_196":      196,
	"PROTO_197":      197,
	"PROTO_198":      198,
	"PROTO_199":      199,
	"PROTO_200":      200,
	"PROTO_201":      201,
	"PROTO_202":      202,
	"PROTO_203":      203,
	"PROTO_204":      204,
	"PROTO_205":      205,
	"PROTO_206":      206,
	"PROTO_207":      207,
	"PROTO_208":      208,
	"PROTO_209":      209,
	"PROTO_210":      210,
	"PROTO_211":      211,
	"PROTO_212":      212,
	"PROTO_213":      213,
	"PROTO_214":      214,
	"PROTO_215":      215,
	"PROTO_216":      216,
	"PROTO_217":      217,
	"PROTO_218":      218,
	"PROTO_219":      219,
	"PROTO_220":      220,
	"PROTO_221":      221,
	"PROTO_222":      222,
	"PROTO_223":      223,
	"PROTO_224":      224,
	"PROTO_225":      225,
	"PROTO_226":      226,
	"PROTO_227":      227,
	"PROTO_228":      228,
	"PROTO_229":      229,
	"PROTO_230":      230,
	"PROTO_231":      231,
	"PROTO_232":      232,
	"PROTO_233":      233,
	"PROTO_234":      234,
	"PROTO_235":      235,
	"PROTO_236":      236,
	"PROTO_237":      237,
	"PROTO_238":      238,
	"PROTO_239":      239,
	"PROTO_240":      240,
	"PROTO_241":      241,
	"PROTO_242":      242,
	"PROTO_243":      243,
	"PROTO_244":      244,
	"PROTO_245":      245,
	"PROTO_246":      246,
	"ARP_REVREQUEST": 247,
	"ARP_REVREPLY":   248,
	"ARP_REQUEST":    249,
	"ARP_REPLY":      250,
	"PROTO_251":      251,
	"PROTO_252":      252,
	"EXPERIMENT1":    253,
	"EXPERIMENT2":    254,
	"RESERVED":       255,
}

func (x IPProtocol) String() string {
	return proto.EnumName(IPProtocol_name, int32(x))
}
func (IPProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Intent_Action int32

const (
	Intent_INVALID Intent_Action = 0
	// Allow the corresponding flows.
	Intent_ALLOW Intent_Action = 1
	// DROP the corresponding flows.
	Intent_DROP Intent_Action = 2
)

var Intent_Action_name = map[int32]string{
	0: "INVALID",
	1: "ALLOW",
	2: "DROP",
}
var Intent_Action_value = map[string]int32{
	"INVALID": 0,
	"ALLOW":   1,
	"DROP":    2,
}

func (x Intent_Action) String() string {
	return proto.EnumName(Intent_Action_name, int32(x))
}
func (Intent_Action) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

// Identifies the enforcement point of the intent.
type Intent_TargetDevice int32

const (
	// Inside VM, Bare-metal or containers.
	Intent_WORKLOAD Intent_TargetDevice = 0
	// In network using SDN tools like ACI.
	Intent_NETWORK_FABRIC Intent_TargetDevice = 1
	// Load balancers and NAT devices that support enforcement.
	Intent_MIDDLE_BOXES Intent_TargetDevice = 2
	// Firewalls
	Intent_FIREWALLS Intent_TargetDevice = 3
)

var Intent_TargetDevice_name = map[int32]string{
	0: "WORKLOAD",
	1: "NETWORK_FABRIC",
	2: "MIDDLE_BOXES",
	3: "FIREWALLS",
}
var Intent_TargetDevice_value = map[string]int32{
	"WORKLOAD":       0,
	"NETWORK_FABRIC": 1,
	"MIDDLE_BOXES":   2,
	"FIREWALLS":      3,
}

func (x Intent_TargetDevice) String() string {
	return proto.EnumName(Intent_TargetDevice_name, int32(x))
}
func (Intent_TargetDevice) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

type CatchAllPolicy_Action int32

const (
	CatchAllPolicy_INVALID CatchAllPolicy_Action = 0
	// Allow the corresponding flows.
	CatchAllPolicy_ALLOW CatchAllPolicy_Action = 1
	// DROP the corresponding flows.
	CatchAllPolicy_DROP CatchAllPolicy_Action = 2
)

var CatchAllPolicy_Action_name = map[int32]string{
	0: "INVALID",
	1: "ALLOW",
	2: "DROP",
}
var CatchAllPolicy_Action_value = map[string]int32{
	"INVALID": 0,
	"ALLOW":   1,
	"DROP":    2,
}

func (x CatchAllPolicy_Action) String() string {
	return proto.EnumName(CatchAllPolicy_Action_name, int32(x))
}
func (CatchAllPolicy_Action) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

// Status of enforcement reported by the client.
type IntentStatus_Status int32

const (
	IntentStatus_UNKNOWN IntentStatus_Status = 0
	// Client cannot enforce this policy.
	IntentStatus_IGNORED IntentStatus_Status = 1
	// Client can enforce this policy. However, encountered an error while
	// trying to enforce the policy.
	IntentStatus_FAILED IntentStatus_Status = 2
	// Successfully enforced.
	IntentStatus_ENFORCED IntentStatus_Status = 3
	// Client enforced a relaxed policy. Indicates that more flows will be
	// allowed than what the intent prescribed. Clients cannot modify the
	// policy to drop flows that intent says allow.
	IntentStatus_MODIFIED_AND_ENFORCED IntentStatus_Status = 4
)

var IntentStatus_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "IGNORED",
	2: "FAILED",
	3: "ENFORCED",
	4: "MODIFIED_AND_ENFORCED",
}
var IntentStatus_Status_value = map[string]int32{
	"UNKNOWN":               0,
	"IGNORED":               1,
	"FAILED":                2,
	"ENFORCED":              3,
	"MODIFIED_AND_ENFORCED": 4,
}

func (x IntentStatus_Status) String() string {
	return proto.EnumName(IntentStatus_Status_name, int32(x))
}
func (IntentStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 0} }

// enum to indicate type of this status message
type TenantNetworkPolicyStatus_StatusType int32

const (
	TenantNetworkPolicyStatus_UNKNOWN_STATUS TenantNetworkPolicyStatus_StatusType = 0
	TenantNetworkPolicyStatus_POLICY_STATUS  TenantNetworkPolicyStatus_StatusType = 1
	TenantNetworkPolicyStatus_LOG_STATUS     TenantNetworkPolicyStatus_StatusType = 2
	TenantNetworkPolicyStatus_HEALTH_STATUS  TenantNetworkPolicyStatus_StatusType = 3
)

var TenantNetworkPolicyStatus_StatusType_name = map[int32]string{
	0: "UNKNOWN_STATUS",
	1: "POLICY_STATUS",
	2: "LOG_STATUS",
	3: "HEALTH_STATUS",
}
var TenantNetworkPolicyStatus_StatusType_value = map[string]int32{
	"UNKNOWN_STATUS": 0,
	"POLICY_STATUS":  1,
	"LOG_STATUS":     2,
	"HEALTH_STATUS":  3,
}

func (x TenantNetworkPolicyStatus_StatusType) String() string {
	return proto.EnumName(TenantNetworkPolicyStatus_StatusType_name, int32(x))
}
func (TenantNetworkPolicyStatus_StatusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{19, 0}
}

type KafkaUpdate_UpdateType int32

const (
	// Start marker for a new policy update.
	KafkaUpdate_UPDATE_START KafkaUpdate_UpdateType = 0
	// Message part of the policy update.
	KafkaUpdate_UPDATE KafkaUpdate_UpdateType = 1
	// End marker for the current policy update.
	KafkaUpdate_UPDATE_END KafkaUpdate_UpdateType = 2
)

var KafkaUpdate_UpdateType_name = map[int32]string{
	0: "UPDATE_START",
	1: "UPDATE",
	2: "UPDATE_END",
}
var KafkaUpdate_UpdateType_value = map[string]int32{
	"UPDATE_START": 0,
	"UPDATE":       1,
	"UPDATE_END":   2,
}

func (x KafkaUpdate_UpdateType) String() string {
	return proto.EnumName(KafkaUpdate_UpdateType_name, int32(x))
}
func (KafkaUpdate_UpdateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{20, 0} }

// IP address with prefix.
type AddressWithPrefix struct {
	// IP Address in Network Byte Order.
	IpAddr       []byte `protobuf:"bytes,1,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	PrefixLength uint32 `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	// Address family
	AddrFamily IPAddressFamily `protobuf:"varint,3,opt,name=addr_family,json=addrFamily,enum=TetrationNetworkPolicyProto.IPAddressFamily" json:"addr_family,omitempty"`
}

func (m *AddressWithPrefix) Reset()                    { *m = AddressWithPrefix{} }
func (m *AddressWithPrefix) String() string            { return proto.CompactTextString(m) }
func (*AddressWithPrefix) ProtoMessage()               {}
func (*AddressWithPrefix) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AddressWithPrefix) GetIpAddr() []byte {
	if m != nil {
		return m.IpAddr
	}
	return nil
}

func (m *AddressWithPrefix) GetPrefixLength() uint32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *AddressWithPrefix) GetAddrFamily() IPAddressFamily {
	if m != nil {
		return m.AddrFamily
	}
	return IPAddressFamily_INVALID
}

// Message to represent a contiguous range of IP Addresses.
type AddressWithRange struct {
	// Start IP Address in Network Byte Order.
	StartIpAddr []byte `protobuf:"bytes,1,opt,name=start_ip_addr,json=startIpAddr,proto3" json:"start_ip_addr,omitempty"`
	// End IP Address in Network Byte Order. End IP Address must be greater than
	// start IP Address.
	EndIpAddr []byte `protobuf:"bytes,2,opt,name=end_ip_addr,json=endIpAddr,proto3" json:"end_ip_addr,omitempty"`
	// Address family
	AddrFamily IPAddressFamily `protobuf:"varint,3,opt,name=addr_family,json=addrFamily,enum=TetrationNetworkPolicyProto.IPAddressFamily" json:"addr_family,omitempty"`
}

func (m *AddressWithRange) Reset()                    { *m = AddressWithRange{} }
func (m *AddressWithRange) String() string            { return proto.CompactTextString(m) }
func (*AddressWithRange) ProtoMessage()               {}
func (*AddressWithRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AddressWithRange) GetStartIpAddr() []byte {
	if m != nil {
		return m.StartIpAddr
	}
	return nil
}

func (m *AddressWithRange) GetEndIpAddr() []byte {
	if m != nil {
		return m.EndIpAddr
	}
	return nil
}

func (m *AddressWithRange) GetAddrFamily() IPAddressFamily {
	if m != nil {
		return m.AddrFamily
	}
	return IPAddressFamily_INVALID
}

// When we enforce on Load Balancer devices we will expose VIPs, URLs and
// service names as members of InventoryGroup. Note that an InventoryGroup
// with members of LBService can be used only as provider_filter_id in
// FlowFilter.
type LBService struct {
	// Types that are valid to be assigned to ServiceName:
	//	*LBService_Vip
	//	*LBService_Url
	//	*LBService_Name
	ServiceName isLBService_ServiceName `protobuf_oneof:"ServiceName"`
}

func (m *LBService) Reset()                    { *m = LBService{} }
func (m *LBService) String() string            { return proto.CompactTextString(m) }
func (*LBService) ProtoMessage()               {}
func (*LBService) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isLBService_ServiceName interface {
	isLBService_ServiceName()
}

type LBService_Vip struct {
	Vip *AddressWithPrefix `protobuf:"bytes,1,opt,name=vip,oneof"`
}
type LBService_Url struct {
	Url string `protobuf:"bytes,2,opt,name=url,oneof"`
}
type LBService_Name struct {
	Name string `protobuf:"bytes,3,opt,name=name,oneof"`
}

func (*LBService_Vip) isLBService_ServiceName()  {}
func (*LBService_Url) isLBService_ServiceName()  {}
func (*LBService_Name) isLBService_ServiceName() {}

func (m *LBService) GetServiceName() isLBService_ServiceName {
	if m != nil {
		return m.ServiceName
	}
	return nil
}

func (m *LBService) GetVip() *AddressWithPrefix {
	if x, ok := m.GetServiceName().(*LBService_Vip); ok {
		return x.Vip
	}
	return nil
}

func (m *LBService) GetUrl() string {
	if x, ok := m.GetServiceName().(*LBService_Url); ok {
		return x.Url
	}
	return ""
}

func (m *LBService) GetName() string {
	if x, ok := m.GetServiceName().(*LBService_Name); ok {
		return x.Name
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LBService) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LBService_OneofMarshaler, _LBService_OneofUnmarshaler, _LBService_OneofSizer, []interface{}{
		(*LBService_Vip)(nil),
		(*LBService_Url)(nil),
		(*LBService_Name)(nil),
	}
}

func _LBService_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LBService)
	// ServiceName
	switch x := m.ServiceName.(type) {
	case *LBService_Vip:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vip); err != nil {
			return err
		}
	case *LBService_Url:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Url)
	case *LBService_Name:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case nil:
	default:
		return fmt.Errorf("LBService.ServiceName has unexpected type %T", x)
	}
	return nil
}

func _LBService_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LBService)
	switch tag {
	case 1: // ServiceName.vip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressWithPrefix)
		err := b.DecodeMessage(msg)
		m.ServiceName = &LBService_Vip{msg}
		return true, err
	case 2: // ServiceName.url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServiceName = &LBService_Url{x}
		return true, err
	case 3: // ServiceName.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServiceName = &LBService_Name{x}
		return true, err
	default:
		return false, nil
	}
}

func _LBService_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LBService)
	// ServiceName
	switch x := m.ServiceName.(type) {
	case *LBService_Vip:
		s := proto.Size(x.Vip)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LBService_Url:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Url)))
		n += len(x.Url)
	case *LBService_Name:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type KeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// An inventory item specifies cluster entities such as servers, appliances.
// It can be either a singular IP address, a subnet or an address range.
type InventoryItem struct {
	// Types that are valid to be assigned to Address:
	//	*InventoryItem_IpAddress
	//	*InventoryItem_AddressRange
	//	*InventoryItem_LbService
	Address isInventoryItem_Address `protobuf_oneof:"address"`
}

func (m *InventoryItem) Reset()                    { *m = InventoryItem{} }
func (m *InventoryItem) String() string            { return proto.CompactTextString(m) }
func (*InventoryItem) ProtoMessage()               {}
func (*InventoryItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isInventoryItem_Address interface {
	isInventoryItem_Address()
}

type InventoryItem_IpAddress struct {
	IpAddress *AddressWithPrefix `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,oneof"`
}
type InventoryItem_AddressRange struct {
	AddressRange *AddressWithRange `protobuf:"bytes,2,opt,name=address_range,json=addressRange,oneof"`
}
type InventoryItem_LbService struct {
	LbService *LBService `protobuf:"bytes,4,opt,name=lb_service,json=lbService,oneof"`
}

func (*InventoryItem_IpAddress) isInventoryItem_Address()    {}
func (*InventoryItem_AddressRange) isInventoryItem_Address() {}
func (*InventoryItem_LbService) isInventoryItem_Address()    {}

func (m *InventoryItem) GetAddress() isInventoryItem_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *InventoryItem) GetIpAddress() *AddressWithPrefix {
	if x, ok := m.GetAddress().(*InventoryItem_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (m *InventoryItem) GetAddressRange() *AddressWithRange {
	if x, ok := m.GetAddress().(*InventoryItem_AddressRange); ok {
		return x.AddressRange
	}
	return nil
}

func (m *InventoryItem) GetLbService() *LBService {
	if x, ok := m.GetAddress().(*InventoryItem_LbService); ok {
		return x.LbService
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InventoryItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InventoryItem_OneofMarshaler, _InventoryItem_OneofUnmarshaler, _InventoryItem_OneofSizer, []interface{}{
		(*InventoryItem_IpAddress)(nil),
		(*InventoryItem_AddressRange)(nil),
		(*InventoryItem_LbService)(nil),
	}
}

func _InventoryItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InventoryItem)
	// address
	switch x := m.Address.(type) {
	case *InventoryItem_IpAddress:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpAddress); err != nil {
			return err
		}
	case *InventoryItem_AddressRange:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddressRange); err != nil {
			return err
		}
	case *InventoryItem_LbService:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LbService); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InventoryItem.Address has unexpected type %T", x)
	}
	return nil
}

func _InventoryItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InventoryItem)
	switch tag {
	case 1: // address.ip_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressWithPrefix)
		err := b.DecodeMessage(msg)
		m.Address = &InventoryItem_IpAddress{msg}
		return true, err
	case 2: // address.address_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressWithRange)
		err := b.DecodeMessage(msg)
		m.Address = &InventoryItem_AddressRange{msg}
		return true, err
	case 4: // address.lb_service
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LBService)
		err := b.DecodeMessage(msg)
		m.Address = &InventoryItem_LbService{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InventoryItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InventoryItem)
	// address
	switch x := m.Address.(type) {
	case *InventoryItem_IpAddress:
		s := proto.Size(x.IpAddress)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InventoryItem_AddressRange:
		s := proto.Size(x.AddressRange)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InventoryItem_LbService:
		s := proto.Size(x.LbService)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Tetration debug information related to InventoryGroups.
type InventoryGroupMetaData struct {
	// ID of the scope where corresponding inventory group is defined.
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId" json:"scope_id,omitempty"`
}

func (m *InventoryGroupMetaData) Reset()                    { *m = InventoryGroupMetaData{} }
func (m *InventoryGroupMetaData) String() string            { return proto.CompactTextString(m) }
func (*InventoryGroupMetaData) ProtoMessage()               {}
func (*InventoryGroupMetaData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *InventoryGroupMetaData) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

// Inventory group represents a grouping of inventory items. They will be
// referenced by Flow Filters.
type InventoryGroup struct {
	// Unique identifier assigned to inventory group. Flow filters will refer
	// to these values. If a given update has multiple InventoryGroup messages
	// with the same id then the clients will merge inventory_items to construct
	// the complete inventory group.
	Id             string           `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	InventoryItems []*InventoryItem `protobuf:"bytes,2,rep,name=inventory_items,json=inventoryItems" json:"inventory_items,omitempty"`
	// Query filter json representation. It enables us to identify the common
	// attributes of inventory_items that group them together.
	Query string `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// Human readable name assigned to this inventory group.
	Name string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Any tags defined in Tetration for a specific inventory group will be
	// provided here.
	// Note these tags are opaque for Tetration. Clients can add these Tags
	// through rest interface. Tetration passes them as-is on Kafka.
	Tags []*KeyValue `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	// Debug information.
	MetaData *InventoryGroupMetaData `protobuf:"bytes,6,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
}

func (m *InventoryGroup) Reset()                    { *m = InventoryGroup{} }
func (m *InventoryGroup) String() string            { return proto.CompactTextString(m) }
func (*InventoryGroup) ProtoMessage()               {}
func (*InventoryGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *InventoryGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InventoryGroup) GetInventoryItems() []*InventoryItem {
	if m != nil {
		return m.InventoryItems
	}
	return nil
}

func (m *InventoryGroup) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *InventoryGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InventoryGroup) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *InventoryGroup) GetMetaData() *InventoryGroupMetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

// Used to represent contiguous port numbers.
type PortRange struct {
	StartPort uint32 `protobuf:"varint,1,opt,name=start_port,json=startPort" json:"start_port,omitempty"`
	EndPort   uint32 `protobuf:"varint,2,opt,name=end_port,json=endPort" json:"end_port,omitempty"`
}

func (m *PortRange) Reset()                    { *m = PortRange{} }
func (m *PortRange) String() string            { return proto.CompactTextString(m) }
func (*PortRange) ProtoMessage()               {}
func (*PortRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PortRange) GetStartPort() uint32 {
	if m != nil {
		return m.StartPort
	}
	return 0
}

func (m *PortRange) GetEndPort() uint32 {
	if m != nil {
		return m.EndPort
	}
	return 0
}

type ProtocolAndPorts struct {
	Protocol   IPProtocol   `protobuf:"varint,1,opt,name=protocol,enum=TetrationNetworkPolicyProto.IPProtocol" json:"protocol,omitempty"`
	PortRanges []*PortRange `protobuf:"bytes,2,rep,name=port_ranges,json=portRanges" json:"port_ranges,omitempty"`
	Ports      []uint32     `protobuf:"varint,3,rep,packed,name=ports" json:"ports,omitempty"`
}

func (m *ProtocolAndPorts) Reset()                    { *m = ProtocolAndPorts{} }
func (m *ProtocolAndPorts) String() string            { return proto.CompactTextString(m) }
func (*ProtocolAndPorts) ProtoMessage()               {}
func (*ProtocolAndPorts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ProtocolAndPorts) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IP
}

func (m *ProtocolAndPorts) GetPortRanges() []*PortRange {
	if m != nil {
		return m.PortRanges
	}
	return nil
}

func (m *ProtocolAndPorts) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Defines the match criteria for Intents.
type FlowFilter struct {
	// Unique id assigned to this FlowFilter.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Id of inventory filter corresponding to consumers of a service.
	ConsumerFilterId string `protobuf:"bytes,2,opt,name=consumer_filter_id,json=consumerFilterId" json:"consumer_filter_id,omitempty"`
	// Id of inventory filter corresponding to providers of a service.
	ProviderFilterId string `protobuf:"bytes,3,opt,name=provider_filter_id,json=providerFilterId" json:"provider_filter_id,omitempty"`
	// List of ports and protocols where the service is accessible.
	ProtocolAndPorts []*ProtocolAndPorts `protobuf:"bytes,4,rep,name=protocol_and_ports,json=protocolAndPorts" json:"protocol_and_ports,omitempty"`
}

func (m *FlowFilter) Reset()                    { *m = FlowFilter{} }
func (m *FlowFilter) String() string            { return proto.CompactTextString(m) }
func (*FlowFilter) ProtoMessage()               {}
func (*FlowFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FlowFilter) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FlowFilter) GetConsumerFilterId() string {
	if m != nil {
		return m.ConsumerFilterId
	}
	return ""
}

func (m *FlowFilter) GetProviderFilterId() string {
	if m != nil {
		return m.ProviderFilterId
	}
	return ""
}

func (m *FlowFilter) GetProtocolAndPorts() []*ProtocolAndPorts {
	if m != nil {
		return m.ProtocolAndPorts
	}
	return nil
}

// Contains debug information from Tetration.
type IntentMetaData struct {
	// The intent due to which this policy exists.
	IntentId string `protobuf:"bytes,1,opt,name=intent_id,json=intentId" json:"intent_id,omitempty"`
	HashId   string `protobuf:"bytes,2,opt,name=hash_id,json=hashId" json:"hash_id,omitempty"`
	// The workspace due to which this policy exists.
	WorkspaceId string `protobuf:"bytes,3,opt,name=workspace_id,json=workspaceId" json:"workspace_id,omitempty"`
	// Fields to help trace the ADM related constructs that is responsible for
	// creating this intent.
	AdmDataSetId        string `protobuf:"bytes,4,opt,name=adm_data_set_id,json=admDataSetId" json:"adm_data_set_id,omitempty"`
	AdmDataSetVersion   string `protobuf:"bytes,5,opt,name=adm_data_set_version,json=admDataSetVersion" json:"adm_data_set_version,omitempty"`
	PolicyIntentGroupId string `protobuf:"bytes,6,opt,name=policy_intent_group_id,json=policyIntentGroupId" json:"policy_intent_group_id,omitempty"`
	ClusterEdgeId       string `protobuf:"bytes,7,opt,name=cluster_edge_id,json=clusterEdgeId" json:"cluster_edge_id,omitempty"`
	// Unique identifier of the scope corresponding to workspace_id.
	ScopeId string `protobuf:"bytes,8,opt,name=scope_id,json=scopeId" json:"scope_id,omitempty"`
	// Human readable scope name.
	ScopeName string `protobuf:"bytes,9,opt,name=scope_name,json=scopeName" json:"scope_name,omitempty"`
}

func (m *IntentMetaData) Reset()                    { *m = IntentMetaData{} }
func (m *IntentMetaData) String() string            { return proto.CompactTextString(m) }
func (*IntentMetaData) ProtoMessage()               {}
func (*IntentMetaData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *IntentMetaData) GetIntentId() string {
	if m != nil {
		return m.IntentId
	}
	return ""
}

func (m *IntentMetaData) GetHashId() string {
	if m != nil {
		return m.HashId
	}
	return ""
}

func (m *IntentMetaData) GetWorkspaceId() string {
	if m != nil {
		return m.WorkspaceId
	}
	return ""
}

func (m *IntentMetaData) GetAdmDataSetId() string {
	if m != nil {
		return m.AdmDataSetId
	}
	return ""
}

func (m *IntentMetaData) GetAdmDataSetVersion() string {
	if m != nil {
		return m.AdmDataSetVersion
	}
	return ""
}

func (m *IntentMetaData) GetPolicyIntentGroupId() string {
	if m != nil {
		return m.PolicyIntentGroupId
	}
	return ""
}

func (m *IntentMetaData) GetClusterEdgeId() string {
	if m != nil {
		return m.ClusterEdgeId
	}
	return ""
}

func (m *IntentMetaData) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *IntentMetaData) GetScopeName() string {
	if m != nil {
		return m.ScopeName
	}
	return ""
}

type Intent struct {
	// Unique id assigned to this Intent.
	Id         string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	FlowFilter *FlowFilter `protobuf:"bytes,2,opt,name=flow_filter,json=flowFilter" json:"flow_filter,omitempty"`
	// Action to be taken for corresponding flows.
	Action Intent_Action `protobuf:"varint,3,opt,name=action,enum=TetrationNetworkPolicyProto.Intent_Action" json:"action,omitempty"`
	// List of target devices where user wants the intent to be enforced. If
	// no target devices are specified then clients should enforce if they
	// can.
	TargetDevices []Intent_TargetDevice `protobuf:"varint,4,rep,packed,name=target_devices,json=targetDevices,enum=TetrationNetworkPolicyProto.Intent_TargetDevice" json:"target_devices,omitempty"`
	// Any tags defined in Tetration for a specific intent will be provided here.
	// Note these tags are opaque for Tetration. Clients can add these Tags
	// through rest interface. Tetration passes them as-is on Kafka.
	Tags []*KeyValue `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	// Tetration debug information. Can be used to link back to Applications and
	// workspaces using either UI or OPenAPI
	MetaData *IntentMetaData `protobuf:"bytes,6,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
	// Human readable Intent name.
	IntentName string `protobuf:"bytes,7,opt,name=intent_name,json=intentName" json:"intent_name,omitempty"`
}

func (m *Intent) Reset()                    { *m = Intent{} }
func (m *Intent) String() string            { return proto.CompactTextString(m) }
func (*Intent) ProtoMessage()               {}
func (*Intent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Intent) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Intent) GetFlowFilter() *FlowFilter {
	if m != nil {
		return m.FlowFilter
	}
	return nil
}

func (m *Intent) GetAction() Intent_Action {
	if m != nil {
		return m.Action
	}
	return Intent_INVALID
}

func (m *Intent) GetTargetDevices() []Intent_TargetDevice {
	if m != nil {
		return m.TargetDevices
	}
	return nil
}

func (m *Intent) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Intent) GetMetaData() *IntentMetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *Intent) GetIntentName() string {
	if m != nil {
		return m.IntentName
	}
	return ""
}

// CatchAll policy action.
type CatchAllPolicy struct {
	Action CatchAllPolicy_Action `protobuf:"varint,1,opt,name=action,enum=TetrationNetworkPolicyProto.CatchAllPolicy_Action" json:"action,omitempty"`
}

func (m *CatchAllPolicy) Reset()                    { *m = CatchAllPolicy{} }
func (m *CatchAllPolicy) String() string            { return proto.CompactTextString(m) }
func (*CatchAllPolicy) ProtoMessage()               {}
func (*CatchAllPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CatchAllPolicy) GetAction() CatchAllPolicy_Action {
	if m != nil {
		return m.Action
	}
	return CatchAllPolicy_INVALID
}

type NetworkPolicy struct {
	// Fully expanded inventory groups.
	InventoryFilters []*InventoryGroup `protobuf:"bytes,1,rep,name=inventory_filters,json=inventoryFilters" json:"inventory_filters,omitempty"`
	// Order of intents in decreasing order of priority.
	Intents []*Intent `protobuf:"bytes,2,rep,name=intents" json:"intents,omitempty"`
	// Catch All policy.
	CatchAll *CatchAllPolicy `protobuf:"bytes,3,opt,name=catch_all,json=catchAll" json:"catch_all,omitempty"`
}

func (m *NetworkPolicy) Reset()                    { *m = NetworkPolicy{} }
func (m *NetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicy) ProtoMessage()               {}
func (*NetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NetworkPolicy) GetInventoryFilters() []*InventoryGroup {
	if m != nil {
		return m.InventoryFilters
	}
	return nil
}

func (m *NetworkPolicy) GetIntents() []*Intent {
	if m != nil {
		return m.Intents
	}
	return nil
}

func (m *NetworkPolicy) GetCatchAll() *CatchAllPolicy {
	if m != nil {
		return m.CatchAll
	}
	return nil
}

type ScopeInfo struct {
	// Unique id of the scope.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Human readable name assigned to the scope.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Unique id of the parent scope.
	ParentId string `protobuf:"bytes,3,opt,name=parent_id,json=parentId" json:"parent_id,omitempty"`
	// Tags are provided by the clients to be assigned to the scopes.  The
	// client will interpret the tag according to its value.  Tags applied
	// to scopes may be applied to items defined within the scope such as
	// InventoryGroups or Intents or they may follow other, client specific,
	// interpretation and application.  Inheritance of tags from parent scopes
	// is generally implied.
	Tags []*KeyValue `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *ScopeInfo) Reset()                    { *m = ScopeInfo{} }
func (m *ScopeInfo) String() string            { return proto.CompactTextString(m) }
func (*ScopeInfo) ProtoMessage()               {}
func (*ScopeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ScopeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ScopeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScopeInfo) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *ScopeInfo) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

type TenantNetworkPolicy struct {
	// Unique name assigned to tenant. It's the same as the root-scope name.
	TenantName string `protobuf:"bytes,1,opt,name=tenant_name,json=tenantName" json:"tenant_name,omitempty"`
	// Network policy corresponding to tenant_name. Note that policy for one
	// tenant might be split across several TenantNetworkPolicy messages. To
	// reconstruct the policy state we need to append NetworkPolicy from multiple
	// messages in the same order of TenantNetworkPolicy.
	NetworkPolicy []*NetworkPolicy `protobuf:"bytes,2,rep,name=network_policy,json=networkPolicy" json:"network_policy,omitempty"`
	// Repeated list of network VRFs that are part of the Tenant. Please note
	// that multiple  network_vrfs are part of single Tetration VRF.
	NetworkVrfs []string `protobuf:"bytes,3,rep,name=network_vrfs,json=networkVrfs" json:"network_vrfs,omitempty"`
	// Each Tenant in Tetration is represented by root scope. Note that
	// root-scope does not have a parent_id.
	RootScopeId string `protobuf:"bytes,4,opt,name=root_scope_id,json=rootScopeId" json:"root_scope_id,omitempty"`
	// Map of all the sub-scopes in root-scopes. The key of this map is the
	// scope id.
	Scopes map[string]*ScopeInfo `protobuf:"bytes,5,rep,name=scopes" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TenantNetworkPolicy) Reset()                    { *m = TenantNetworkPolicy{} }
func (m *TenantNetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*TenantNetworkPolicy) ProtoMessage()               {}
func (*TenantNetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *TenantNetworkPolicy) GetTenantName() string {
	if m != nil {
		return m.TenantName
	}
	return ""
}

func (m *TenantNetworkPolicy) GetNetworkPolicy() []*NetworkPolicy {
	if m != nil {
		return m.NetworkPolicy
	}
	return nil
}

func (m *TenantNetworkPolicy) GetNetworkVrfs() []string {
	if m != nil {
		return m.NetworkVrfs
	}
	return nil
}

func (m *TenantNetworkPolicy) GetRootScopeId() string {
	if m != nil {
		return m.RootScopeId
	}
	return ""
}

func (m *TenantNetworkPolicy) GetScopes() map[string]*ScopeInfo {
	if m != nil {
		return m.Scopes
	}
	return nil
}

type IntentStatus struct {
	// unique id assigned to the intent in NetworkPolicy.
	IntentId string              `protobuf:"bytes,1,opt,name=intent_id,json=intentId" json:"intent_id,omitempty"`
	Status   IntentStatus_Status `protobuf:"varint,2,opt,name=status,enum=TetrationNetworkPolicyProto.IntentStatus_Status" json:"status,omitempty"`
	// Time when the status of the intent has changed. Time is measured as number
	// of microseconds that have elapsed since unix epoch started.
	TimestampUsec uint64 `protobuf:"varint,3,opt,name=timestamp_usec,json=timestampUsec" json:"timestamp_usec,omitempty"`
	// This message is set only when the status is MODIFIED_AND_ENFORCED. This
	// will let the clients inform Tetration on how the intent was modified.
	ModifiedFlowFilter *FlowFilter `protobuf:"bytes,4,opt,name=modified_flow_filter,json=modifiedFlowFilter" json:"modified_flow_filter,omitempty"`
	// If status is set to IGNORED or FAILED then client will include any debug
	// info in status_reason.
	StatusReason string `protobuf:"bytes,5,opt,name=status_reason,json=statusReason" json:"status_reason,omitempty"`
	// Tetration debug information per intent, see also message type Intent.
	// Clients shall return this field as received from Tetration.
	MetaData *IntentMetaData `protobuf:"bytes,6,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
}

func (m *IntentStatus) Reset()                    { *m = IntentStatus{} }
func (m *IntentStatus) String() string            { return proto.CompactTextString(m) }
func (*IntentStatus) ProtoMessage()               {}
func (*IntentStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *IntentStatus) GetIntentId() string {
	if m != nil {
		return m.IntentId
	}
	return ""
}

func (m *IntentStatus) GetStatus() IntentStatus_Status {
	if m != nil {
		return m.Status
	}
	return IntentStatus_UNKNOWN
}

func (m *IntentStatus) GetTimestampUsec() uint64 {
	if m != nil {
		return m.TimestampUsec
	}
	return 0
}

func (m *IntentStatus) GetModifiedFlowFilter() *FlowFilter {
	if m != nil {
		return m.ModifiedFlowFilter
	}
	return nil
}

func (m *IntentStatus) GetStatusReason() string {
	if m != nil {
		return m.StatusReason
	}
	return ""
}

func (m *IntentStatus) GetMetaData() *IntentMetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

type NetworkPolicyStatus struct {
	IntentStatus []*IntentStatus `protobuf:"bytes,1,rep,name=intent_status,json=intentStatus" json:"intent_status,omitempty"`
}

func (m *NetworkPolicyStatus) Reset()                    { *m = NetworkPolicyStatus{} }
func (m *NetworkPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicyStatus) ProtoMessage()               {}
func (*NetworkPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *NetworkPolicyStatus) GetIntentStatus() []*IntentStatus {
	if m != nil {
		return m.IntentStatus
	}
	return nil
}

// This message contains health status of agent (application) enforcing policies.
// Keep in mind this is not the health status of load balancers, which
// the policies are deployed to.
type AgentHealth struct {
	UptimeUsec uint64 `protobuf:"varint,1,opt,name=uptime_usec,json=uptimeUsec" json:"uptime_usec,omitempty"`
	// optional key value pairs of sysinfo-like metrics
	Sysinfo map[string]string `protobuf:"bytes,2,rep,name=sysinfo" json:"sysinfo,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AgentHealth) Reset()                    { *m = AgentHealth{} }
func (m *AgentHealth) String() string            { return proto.CompactTextString(m) }
func (*AgentHealth) ProtoMessage()               {}
func (*AgentHealth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *AgentHealth) GetUptimeUsec() uint64 {
	if m != nil {
		return m.UptimeUsec
	}
	return 0
}

func (m *AgentHealth) GetSysinfo() map[string]string {
	if m != nil {
		return m.Sysinfo
	}
	return nil
}

// Status of policy enforcement as reported by one of the clients consuming
// TenantNetworkPolicy. Note that multiple clients can be consuming the same
// policy and enforcing at different point on the network. For example, a
// client for middle-boxes like load balancers might be enforcing a subset
// of the policies. These clients will report the status of what they are
// enforcing. Similarly a client for network orchestrator like ACI might
// enforce all the policies and report its enforcement status.
type TenantNetworkPolicyStatus struct {
	// Unique name assigned to tenant. It's the same as the root-scope name.
	TenantName string `protobuf:"bytes,1,opt,name=tenant_name,json=tenantName" json:"tenant_name,omitempty"`
	// Just like TenantNetworkPolicy we can have TenantNetworkPolicyStatus for
	// one tenant split across several TenantNetworkPolicyStatus messages. To
	// reconstruct the policy status we need to append NetworkPolicyStatus
	// from multiple messages.
	NetworkPolicyStatus []*NetworkPolicyStatus `protobuf:"bytes,2,rep,name=network_policy_status,json=networkPolicyStatus" json:"network_policy_status,omitempty"`
	RootScopeId         string                 `protobuf:"bytes,3,opt,name=root_scope_id,json=rootScopeId" json:"root_scope_id,omitempty"`
	// Unique id assigned to the client that is reporting enforcement status.
	// For POLICY_STATUS type this should be the load balancer's id.
	ClientId string `protobuf:"bytes,4,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// Client release version.
	ClientVersion string                               `protobuf:"bytes,5,opt,name=client_version,json=clientVersion" json:"client_version,omitempty"`
	Type          TenantNetworkPolicyStatus_StatusType `protobuf:"varint,6,opt,name=type,enum=TetrationNetworkPolicyProto.TenantNetworkPolicyStatus_StatusType" json:"type,omitempty"`
	// For LOG_STATUS and HEALTH_STATUS type this must be set to identify the agent,
	// which deploys the received policies to the managed load balancers.
	AgentId     string       `protobuf:"bytes,7,opt,name=agent_id,json=agentId" json:"agent_id,omitempty"`
	AgentLogs   []string     `protobuf:"bytes,8,rep,name=agent_logs,json=agentLogs" json:"agent_logs,omitempty"`
	AgentHealth *AgentHealth `protobuf:"bytes,9,opt,name=agent_health,json=agentHealth" json:"agent_health,omitempty"`
}

func (m *TenantNetworkPolicyStatus) Reset()                    { *m = TenantNetworkPolicyStatus{} }
func (m *TenantNetworkPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*TenantNetworkPolicyStatus) ProtoMessage()               {}
func (*TenantNetworkPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *TenantNetworkPolicyStatus) GetTenantName() string {
	if m != nil {
		return m.TenantName
	}
	return ""
}

func (m *TenantNetworkPolicyStatus) GetNetworkPolicyStatus() []*NetworkPolicyStatus {
	if m != nil {
		return m.NetworkPolicyStatus
	}
	return nil
}

func (m *TenantNetworkPolicyStatus) GetRootScopeId() string {
	if m != nil {
		return m.RootScopeId
	}
	return ""
}

func (m *TenantNetworkPolicyStatus) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *TenantNetworkPolicyStatus) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *TenantNetworkPolicyStatus) GetType() TenantNetworkPolicyStatus_StatusType {
	if m != nil {
		return m.Type
	}
	return TenantNetworkPolicyStatus_UNKNOWN_STATUS
}

func (m *TenantNetworkPolicyStatus) GetAgentId() string {
	if m != nil {
		return m.AgentId
	}
	return ""
}

func (m *TenantNetworkPolicyStatus) GetAgentLogs() []string {
	if m != nil {
		return m.AgentLogs
	}
	return nil
}

func (m *TenantNetworkPolicyStatus) GetAgentHealth() *AgentHealth {
	if m != nil {
		return m.AgentHealth
	}
	return nil
}

// The network policy updates we send over Kafka can be large; over a couple of
// GB each. Given that it is recommended to keep individual Kafka messages under
// 10MB we split each policy update into several smaller Kafka messages. To
// enable clients to correctly reconstruct the state and handle error scenarios
// we wrap each Kafka message under KafkaUpdate proto. Every policy update will
// have a begin marker UPDATE_START and end marker UPDATE_END.
// To reiterate every Policy update will have following set of messages:
//           - UPDATE_START indicates a new policy update begins.
//           - Several UPDATE messages with increasing sequence numbers.
//           - UPDATE_END indicates the new policy update is complete.
// Note that the first message (UPDATE_START) sequence number is zero and
// subsequent message's sequence numbers are strictly incremented by one.
// A client reading these updates should read all the messages from UPDATE_START
// to UPDATE_END. If any message is missing then client should skip all the
// messages until the next UPDATE_START message.
type KafkaUpdate struct {
	// Type of update message.
	Type KafkaUpdate_UpdateType `protobuf:"varint,1,opt,name=type,enum=TetrationNetworkPolicyProto.KafkaUpdate_UpdateType" json:"type,omitempty"`
	// Sequence number, starting with zero, is incremented by 1 for each
	// message that is part of a policy update.
	SequenceNum uint32 `protobuf:"varint,2,opt,name=sequence_num,json=sequenceNum" json:"sequence_num,omitempty"`
	// Partial details of the network policy. For Intents that are part of
	// different KafkaUpdate messages: the Intents in earlier message have higher
	// priority than intents in later messages. This message is populated on
	// Kafka where policy updates are pushed by Tetration.
	TenantNetworkPolicy *TenantNetworkPolicy `protobuf:"bytes,3,opt,name=tenant_network_policy,json=tenantNetworkPolicy" json:"tenant_network_policy,omitempty"`
	// Monotonically increasing version number of policy state.
	Version uint64 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	// This message is populated in Kafka topics that Tenants publish the
	// status of enforcement.
	NetworkPolicyStatus *TenantNetworkPolicyStatus `protobuf:"bytes,5,opt,name=network_policy_status,json=networkPolicyStatus" json:"network_policy_status,omitempty"`
}

func (m *KafkaUpdate) Reset()                    { *m = KafkaUpdate{} }
func (m *KafkaUpdate) String() string            { return proto.CompactTextString(m) }
func (*KafkaUpdate) ProtoMessage()               {}
func (*KafkaUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *KafkaUpdate) GetType() KafkaUpdate_UpdateType {
	if m != nil {
		return m.Type
	}
	return KafkaUpdate_UPDATE_START
}

func (m *KafkaUpdate) GetSequenceNum() uint32 {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *KafkaUpdate) GetTenantNetworkPolicy() *TenantNetworkPolicy {
	if m != nil {
		return m.TenantNetworkPolicy
	}
	return nil
}

func (m *KafkaUpdate) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *KafkaUpdate) GetNetworkPolicyStatus() *TenantNetworkPolicyStatus {
	if m != nil {
		return m.NetworkPolicyStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*AddressWithPrefix)(nil), "TetrationNetworkPolicyProto.AddressWithPrefix")
	proto.RegisterType((*AddressWithRange)(nil), "TetrationNetworkPolicyProto.AddressWithRange")
	proto.RegisterType((*LBService)(nil), "TetrationNetworkPolicyProto.LBService")
	proto.RegisterType((*KeyValue)(nil), "TetrationNetworkPolicyProto.KeyValue")
	proto.RegisterType((*InventoryItem)(nil), "TetrationNetworkPolicyProto.InventoryItem")
	proto.RegisterType((*InventoryGroupMetaData)(nil), "TetrationNetworkPolicyProto.InventoryGroupMetaData")
	proto.RegisterType((*InventoryGroup)(nil), "TetrationNetworkPolicyProto.InventoryGroup")
	proto.RegisterType((*PortRange)(nil), "TetrationNetworkPolicyProto.PortRange")
	proto.RegisterType((*ProtocolAndPorts)(nil), "TetrationNetworkPolicyProto.ProtocolAndPorts")
	proto.RegisterType((*FlowFilter)(nil), "TetrationNetworkPolicyProto.FlowFilter")
	proto.RegisterType((*IntentMetaData)(nil), "TetrationNetworkPolicyProto.IntentMetaData")
	proto.RegisterType((*Intent)(nil), "TetrationNetworkPolicyProto.Intent")
	proto.RegisterType((*CatchAllPolicy)(nil), "TetrationNetworkPolicyProto.CatchAllPolicy")
	proto.RegisterType((*NetworkPolicy)(nil), "TetrationNetworkPolicyProto.NetworkPolicy")
	proto.RegisterType((*ScopeInfo)(nil), "TetrationNetworkPolicyProto.ScopeInfo")
	proto.RegisterType((*TenantNetworkPolicy)(nil), "TetrationNetworkPolicyProto.TenantNetworkPolicy")
	proto.RegisterType((*IntentStatus)(nil), "TetrationNetworkPolicyProto.IntentStatus")
	proto.RegisterType((*NetworkPolicyStatus)(nil), "TetrationNetworkPolicyProto.NetworkPolicyStatus")
	proto.RegisterType((*AgentHealth)(nil), "TetrationNetworkPolicyProto.AgentHealth")
	proto.RegisterType((*TenantNetworkPolicyStatus)(nil), "TetrationNetworkPolicyProto.TenantNetworkPolicyStatus")
	proto.RegisterType((*KafkaUpdate)(nil), "TetrationNetworkPolicyProto.KafkaUpdate")
	proto.RegisterEnum("TetrationNetworkPolicyProto.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.IPProtocol", IPProtocol_name, IPProtocol_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.Intent_Action", Intent_Action_name, Intent_Action_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.Intent_TargetDevice", Intent_TargetDevice_name, Intent_TargetDevice_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.CatchAllPolicy_Action", CatchAllPolicy_Action_name, CatchAllPolicy_Action_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.IntentStatus_Status", IntentStatus_Status_name, IntentStatus_Status_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.TenantNetworkPolicyStatus_StatusType", TenantNetworkPolicyStatus_StatusType_name, TenantNetworkPolicyStatus_StatusType_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.KafkaUpdate_UpdateType", KafkaUpdate_UpdateType_name, KafkaUpdate_UpdateType_value)
}

func init() { proto.RegisterFile("proto/tetration_network_policy.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 3451 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x9a, 0x77, 0x78, 0x23, 0xc7,
	0x75, 0xc0, 0x0f, 0x00, 0x8f, 0x24, 0x06, 0x00, 0xef, 0xdd, 0xde, 0x49, 0xa6, 0x74, 0xb1, 0x75,
	0x07, 0x59, 0xf2, 0xf9, 0xac, 0x50, 0x04, 0x40, 0x82, 0xa4, 0x22, 0x27, 0x59, 0x00, 0x0b, 0x60,
	0x4d, 0x60, 0x31, 0x37, 0xbb, 0x2c, 0x17, 0x27, 0x41, 0x56, 0xc0, 0x92, 0x84, 0x85, 0x26, 0xec,
	0x92, 0x32, 0xd3, 0xab, 0x5b, 0x7a, 0xef, 0x89, 0x9d, 0xd8, 0xa9, 0x4e, 0x4f, 0x9c, 0xe2, 0x24,
	0x76, 0x7a, 0xef, 0xd5, 0x89, 0xd3, 0x7b, 0x4f, 0x9c, 0xde, 0xf3, 0xbd, 0x37, 0x0b, 0x10, 0xa3,
	0xbb, 0xf0, 0x78, 0xb6, 0xfe, 0xe2, 0xfc, 0xde, 0xcc, 0xbc, 0x79, 0x33, 0xaf, 0xcc, 0x2c, 0x3f,
	0xb0, 0x17, 0x0f, 0x47, 0x83, 0x60, 0xf0, 0x78, 0xe0, 0x05, 0x23, 0x37, 0xe8, 0x0c, 0xfa, 0xcd,
	0xbe, 0x17, 0x3c, 0x3b, 0x18, 0x3d, 0xdd, 0x1c, 0x0e, 0xba, 0x9d, 0xd6, 0xf1, 0x12, 0x75, 0x6b,
	0x57, 0x9c, 0x71, 0xbf, 0x25, 0xbb, 0x39, 0xf5, 0x72, 0xec, 0x4c, 0xbf, 0x31, 0xc2, 0x2e, 0xea,
	0xed, 0xf6, 0xc8, 0xf3, 0xfd, 0x9d, 0x4e, 0x70, 0xc0, 0x47, 0xde, 0x5e, 0xe7, 0xd5, 0xda, 0x0b,
	0xd8, 0x5c, 0x67, 0xd8, 0x74, 0xdb, 0xed, 0xd1, 0x62, 0xe4, 0x6a, 0xe4, 0x7a, 0x52, 0xcc, 0x76,
	0x86, 0x38, 0x4a, 0x7b, 0x98, 0xa5, 0x86, 0x34, 0xa4, 0xd9, 0xf5, 0xfa, 0xfb, 0xc1, 0xc1, 0x62,
	0xf4, 0x6a, 0xe4, 0x7a, 0x4a, 0x24, 0xa5, 0xb0, 0x46, 0x32, 0xad, 0xce, 0x12, 0x38, 0xb5, 0xb9,
	0xe7, 0xf6, 0x3a, 0xdd, 0xe3, 0xc5, 0xd8, 0xd5, 0xc8, 0xf5, 0x85, 0xec, 0x63, 0x4b, 0xa7, 0x98,
	0xb1, 0x64, 0xf2, 0xd0, 0x88, 0x32, 0xcd, 0x11, 0x0c, 0x15, 0xc8, 0x76, 0xfa, 0x2d, 0x11, 0x06,
	0x53, 0x26, 0x0a, 0xb7, 0xbf, 0xef, 0x69, 0x69, 0x96, 0xf2, 0x03, 0x77, 0x14, 0x34, 0x55, 0x3b,
	0x13, 0x24, 0x34, 0xa5, 0xb1, 0x2f, 0x62, 0x09, 0xaf, 0xdf, 0x9e, 0x8c, 0x88, 0xd2, 0x88, 0xb8,
	0xd7, 0x6f, 0x87, 0xfd, 0xcf, 0xb3, 0x9d, 0xaf, 0x8b, 0xb0, 0x78, 0xad, 0x60, 0x7b, 0xa3, 0xa3,
	0x4e, 0xcb, 0xd3, 0x0a, 0x2c, 0x76, 0xd4, 0x19, 0x92, 0x59, 0x89, 0xec, 0xd2, 0xa9, 0x4a, 0x6f,
	0x3b, 0xff, 0xea, 0x39, 0x81, 0x93, 0x35, 0x8d, 0xc5, 0x0e, 0x47, 0x5d, 0x32, 0x3c, 0x8e, 0xb2,
	0xc3, 0x51, 0x57, 0xbb, 0xcc, 0x66, 0xfa, 0x6e, 0xcf, 0x23, 0x6b, 0x51, 0x48, 0x54, 0x48, 0xb1,
	0x44, 0xb8, 0xb0, 0xe5, 0xf6, 0xbc, 0x74, 0x96, 0xcd, 0x6f, 0x7a, 0xc7, 0xdb, 0x6e, 0xf7, 0xd0,
	0xd3, 0x80, 0xc5, 0x9e, 0xf6, 0x8e, 0xc9, 0x90, 0xb8, 0xc0, 0xa6, 0x76, 0x99, 0x9d, 0x3f, 0xc2,
	0x2e, 0xa9, 0x58, 0x48, 0x48, 0xbf, 0x21, 0xca, 0x52, 0x66, 0xff, 0xc8, 0xeb, 0x07, 0x83, 0xd1,
	0xb1, 0x19, 0x78, 0x3d, 0xad, 0xc1, 0x58, 0x78, 0x76, 0x9e, 0xef, 0xbf, 0xd7, 0x3b, 0x89, 0xcb,
	0xd0, 0xf1, 0x7c, 0x5f, 0x73, 0x58, 0x2a, 0xd4, 0xd6, 0x1c, 0xa1, 0x17, 0xc9, 0x80, 0x44, 0xf6,
	0xfd, 0xcf, 0xaa, 0x93, 0x5c, 0x5f, 0x3d, 0x27, 0x92, 0xa1, 0x16, 0x19, 0x0a, 0x15, 0xc6, 0xba,
	0x4f, 0x35, 0x7d, 0xb9, 0xfd, 0xc5, 0x19, 0x52, 0xf9, 0xe8, 0xa9, 0x2a, 0x27, 0x5e, 0x42, 0xf3,
	0xba, 0x4f, 0x85, 0x50, 0x88, 0xb3, 0xb9, 0x50, 0x71, 0x3a, 0xc7, 0xee, 0x9f, 0x9c, 0x45, 0x65,
	0x34, 0x38, 0x1c, 0xd6, 0xbd, 0xc0, 0x2d, 0xb9, 0x81, 0xab, 0x3d, 0xc0, 0xe6, 0xfd, 0xd6, 0x60,
	0xe8, 0x35, 0x3b, 0xed, 0xf0, 0x4c, 0xe7, 0x88, 0xcd, 0x76, 0xfa, 0xad, 0x51, 0xb6, 0xa0, 0xce,
	0xd2, 0x16, 0x58, 0x74, 0x32, 0x2e, 0xda, 0x69, 0x6b, 0x36, 0xbb, 0xd0, 0x19, 0x8f, 0x68, 0x76,
	0x02, 0xaf, 0xe7, 0x2f, 0x46, 0xaf, 0xc6, 0xae, 0x27, 0xb2, 0x37, 0x4e, 0x0f, 0xbb, 0x69, 0xbf,
	0x88, 0x85, 0xce, 0x34, 0xfa, 0xe8, 0xcf, 0x67, 0x0e, 0xbd, 0x91, 0x8c, 0xe0, 0xb8, 0x90, 0xa0,
	0x69, 0x61, 0xa0, 0xcc, 0x90, 0x90, 0xda, 0xda, 0x06, 0x9b, 0x09, 0xdc, 0x7d, 0x7f, 0xf1, 0x3c,
	0xad, 0xf9, 0xc8, 0xa9, 0x6b, 0x8e, 0x03, 0x48, 0xd0, 0x14, 0x8d, 0xb3, 0x78, 0xcf, 0x0b, 0xdc,
	0x66, 0xdb, 0x0d, 0xdc, 0xc5, 0x59, 0x3a, 0xe4, 0xdc, 0xd9, 0x6c, 0x56, 0xce, 0x4f, 0xcc, 0xf7,
	0xc2, 0x56, 0xda, 0x60, 0x71, 0x3e, 0x18, 0x05, 0xd2, 0x89, 0x2f, 0x64, 0x4c, 0xe6, 0xf3, 0x70,
	0x30, 0x0a, 0xe8, 0xc0, 0x52, 0x22, 0x4e, 0x12, 0x1c, 0x83, 0xa7, 0x8e, 0xa9, 0x4c, 0x9d, 0xb2,
	0xe4, 0xcc, 0x79, 0xfd, 0x36, 0x76, 0xa5, 0xdf, 0x16, 0x61, 0x40, 0x2b, 0xb6, 0x06, 0x5d, 0x5d,
	0xca, 0x7c, 0xad, 0xc8, 0xe6, 0x87, 0xa1, 0x8c, 0x94, 0x2d, 0x64, 0x5f, 0x72, 0x97, 0xbc, 0x1e,
	0xab, 0x10, 0x93, 0x89, 0x5a, 0x85, 0x25, 0x70, 0x41, 0x19, 0xab, 0x63, 0x47, 0x9d, 0x1e, 0x59,
	0x93, 0x0d, 0x09, 0x36, 0x1c, 0x37, 0xc9, 0x41, 0x48, 0xfe, 0x62, 0xec, 0x6a, 0xec, 0x7a, 0x4a,
	0x48, 0x48, 0xbf, 0x2b, 0xc2, 0x58, 0xb9, 0x3b, 0x78, 0xb6, 0xdc, 0xe9, 0x06, 0xde, 0x48, 0xd3,
	0x4e, 0x42, 0xa5, 0x10, 0x5d, 0x8c, 0x50, 0xb8, 0x3c, 0xc6, 0xb4, 0xd6, 0xa0, 0xef, 0x1f, 0xf6,
	0xbc, 0x51, 0x73, 0x8f, 0x86, 0x61, 0xd8, 0xc9, 0xb4, 0x85, 0x71, 0x8f, 0x9c, 0x6f, 0xd2, 0xe8,
	0xe1, 0x68, 0x70, 0xd4, 0x69, 0x2b, 0xa3, 0x65, 0x50, 0xc0, 0xb8, 0x67, 0x32, 0xfa, 0x95, 0x34,
	0x9a, 0x76, 0xda, 0x74, 0xc3, 0xb3, 0xf5, 0x17, 0x67, 0x68, 0x93, 0xa7, 0x67, 0xe4, 0x73, 0x4f,
	0x9b, 0x94, 0x2b, 0x92, 0xf4, 0xbb, 0x29, 0x15, 0x02, 0xaf, 0x1f, 0x4c, 0x12, 0xe7, 0x0a, 0x8b,
	0x77, 0x48, 0x72, 0x92, 0x39, 0xf3, 0x52, 0x60, 0xb6, 0xf1, 0xc2, 0x39, 0x70, 0xfd, 0x83, 0x93,
	0xdd, 0xcd, 0x22, 0x9a, 0x6d, 0xed, 0x1a, 0x4b, 0xe2, 0xf2, 0xfe, 0xd0, 0x6d, 0x79, 0x27, 0xbb,
	0x49, 0x4c, 0x64, 0x66, 0x5b, 0x7b, 0x84, 0x5d, 0x70, 0xdb, 0x3d, 0x0a, 0xcc, 0xa6, 0xef, 0x91,
	0x7a, 0x19, 0xf3, 0x49, 0xb7, 0xdd, 0xc3, 0xa5, 0x6d, 0x0f, 0x97, 0x78, 0x9c, 0x5d, 0x56, 0x86,
	0x1d, 0x79, 0x23, 0xbf, 0x33, 0xe8, 0x2f, 0x9e, 0xa7, 0xb1, 0x17, 0x4f, 0xc6, 0x6e, 0xcb, 0x0e,
	0x2d, 0xc7, 0xee, 0x97, 0xf7, 0x68, 0x33, 0xb4, 0x7b, 0x1f, 0x03, 0x19, 0xd5, 0xcf, 0xd2, 0x94,
	0x4b, 0xb2, 0x57, 0x6e, 0x93, 0x82, 0xdc, 0x6c, 0x6b, 0x8f, 0xb2, 0x0b, 0xad, 0xee, 0xa1, 0x8f,
	0x67, 0xef, 0xb5, 0xf7, 0xc9, 0xe4, 0x39, 0x1a, 0x9d, 0x0a, 0xc5, 0x46, 0x7b, 0x1f, 0x8d, 0x9e,
	0x2e, 0x23, 0xf3, 0x4a, 0x19, 0xd1, 0xae, 0x31, 0x26, 0xbb, 0x28, 0x7d, 0xe3, 0x93, 0x80, 0x88,
	0x93, 0x94, 0xea, 0xfb, 0x9b, 0x67, 0xd8, 0xac, 0x5c, 0xf7, 0xb6, 0x0a, 0x53, 0x65, 0x89, 0xbd,
	0xee, 0xe0, 0xd9, 0x30, 0x00, 0xc2, 0x0a, 0x7b, 0x7a, 0xf0, 0x9f, 0x04, 0xa1, 0x60, 0x7b, 0x27,
	0x01, 0x59, 0x60, 0xb3, 0x6e, 0x0b, 0xa7, 0x84, 0x37, 0xe3, 0xdd, 0x4a, 0x14, 0x9a, 0xb3, 0xa4,
	0xd3, 0x0c, 0x11, 0xce, 0xd4, 0x76, 0xd8, 0x42, 0xe0, 0x8e, 0xf6, 0xbd, 0xa0, 0xd9, 0xf6, 0xb0,
	0xc6, 0xca, 0x00, 0x5b, 0xc8, 0x2e, 0x9f, 0x45, 0x97, 0x43, 0x33, 0x4b, 0x34, 0x51, 0xa4, 0x82,
	0x29, 0xf2, 0xdf, 0x97, 0x4a, 0x56, 0xbd, 0xbd, 0x92, 0xbd, 0xec, 0x0c, 0xe6, 0xdc, 0x5e, 0xc1,
	0xb4, 0x87, 0x58, 0x22, 0x0c, 0x0d, 0x72, 0x95, 0x74, 0x34, 0x93, 0x22, 0xf2, 0xd3, 0x0d, 0x36,
	0x2b, 0x0f, 0x44, 0x4b, 0xb0, 0x39, 0xd3, 0xda, 0xd6, 0x6b, 0x66, 0x09, 0xce, 0x69, 0x71, 0x76,
	0x5e, 0xaf, 0xd5, 0x1a, 0x3b, 0x10, 0xd1, 0xe6, 0xd9, 0x4c, 0x49, 0x34, 0x38, 0x44, 0xd3, 0x37,
	0x59, 0x72, 0x7a, 0xc3, 0x5a, 0x92, 0xcd, 0xef, 0x34, 0xc4, 0x66, 0xad, 0xa1, 0xe3, 0x14, 0x8d,
	0x2d, 0x58, 0x86, 0x83, 0x82, 0x66, 0x59, 0x2f, 0x08, 0xb3, 0x08, 0x11, 0x0d, 0x58, 0xb2, 0x6e,
	0x96, 0x4a, 0x35, 0xa3, 0x59, 0x68, 0xec, 0x1a, 0x36, 0x44, 0xb5, 0x14, 0x8b, 0x97, 0x4d, 0x61,
	0xec, 0xe8, 0xb5, 0x9a, 0x0d, 0x31, 0x7c, 0x91, 0x2c, 0x14, 0xdd, 0xa0, 0x75, 0xa0, 0x77, 0xbb,
	0x72, 0x43, 0xda, 0x2b, 0x26, 0x4e, 0x95, 0x65, 0x31, 0x7b, 0xea, 0xce, 0xd5, 0xc9, 0xcf, 0x71,
	0xee, 0x3d, 0xed, 0xee, 0x3d, 0x11, 0x96, 0x52, 0x16, 0xd0, 0x76, 0xd9, 0xc5, 0x93, 0xab, 0x50,
	0x46, 0x2b, 0x3e, 0x32, 0x62, 0x67, 0x70, 0xc7, 0xf4, 0xc5, 0x22, 0x60, 0xa2, 0x45, 0xc6, 0xad,
	0xaf, 0xbd, 0x9c, 0xcd, 0x49, 0x1f, 0x8c, 0x6b, 0xf6, 0xc3, 0x67, 0x70, 0xaf, 0x18, 0xcf, 0xc1,
	0xf8, 0x68, 0xe1, 0xbe, 0x9b, 0x6e, 0xb7, 0x4b, 0xa1, 0x7f, 0x37, 0x83, 0xd4, 0x53, 0x12, 0xf3,
	0xad, 0x90, 0xd3, 0xaf, 0x8d, 0xb0, 0xb8, 0x4d, 0x59, 0xdd, 0xdf, 0x1b, 0xdc, 0x96, 0xa9, 0xe3,
	0x0b, 0x3a, 0x3a, 0x75, 0x41, 0x5f, 0x61, 0xf1, 0xa1, 0x3b, 0x0a, 0x8b, 0xa4, 0xac, 0x75, 0xf3,
	0x52, 0x60, 0xb6, 0x27, 0x31, 0x3f, 0x73, 0xcf, 0x31, 0x9f, 0x7e, 0x7d, 0x8c, 0x5d, 0x72, 0xbc,
	0xbe, 0xdb, 0x0f, 0x54, 0x27, 0x3c, 0xc4, 0x12, 0x01, 0x89, 0x65, 0x04, 0x4b, 0xe3, 0x98, 0x14,
	0x61, 0x04, 0x6b, 0x37, 0xd9, 0x82, 0xfa, 0x51, 0x71, 0xa6, 0xf7, 0x8a, 0x22, 0x12, 0xa9, 0xbe,
	0xb2, 0xe6, 0x35, 0x96, 0x1c, 0xab, 0x3c, 0x1a, 0xed, 0xc9, 0x4b, 0x31, 0x2e, 0x12, 0xa1, 0x6c,
	0x7b, 0xb4, 0xe7, 0xe3, 0xeb, 0x7e, 0x34, 0x18, 0x04, 0xcd, 0x49, 0x89, 0x94, 0x05, 0x3d, 0x81,
	0x42, 0x3b, 0x2c, 0x93, 0x0e, 0x9b, 0xa5, 0xee, 0x71, 0x0d, 0x78, 0xf2, 0x54, 0x8b, 0xee, 0xb0,
	0xf9, 0x25, 0xd2, 0xe4, 0x1b, 0xfd, 0x60, 0x74, 0x2c, 0x42, 0x5d, 0x0f, 0xba, 0x2c, 0x31, 0x25,
	0xbe, 0xc3, 0xe3, 0xf9, 0xc9, 0xe9, 0xc7, 0xf3, 0xdd, 0x9e, 0x03, 0x13, 0xe7, 0x87, 0x8f, 0xec,
	0x27, 0xa2, 0xeb, 0x91, 0xf4, 0x3b, 0x62, 0x2c, 0x29, 0x63, 0xce, 0x0e, 0xdc, 0xe0, 0xd0, 0x3f,
	0xfd, 0x66, 0xac, 0xb2, 0x59, 0x9f, 0x86, 0xd1, 0x82, 0x67, 0xab, 0x9c, 0x52, 0xef, 0x92, 0xfc,
	0x23, 0xc2, 0xf9, 0xda, 0x23, 0x6c, 0x21, 0xe8, 0xf4, 0x3c, 0x3f, 0x70, 0x7b, 0xc3, 0xe6, 0xa1,
	0xef, 0xb5, 0x28, 0xc0, 0x66, 0x44, 0x6a, 0x22, 0xdd, 0xf2, 0xbd, 0x96, 0x76, 0x8b, 0x5d, 0xee,
	0x0d, 0xda, 0x9d, 0xbd, 0x8e, 0xd7, 0x6e, 0x4e, 0xdf, 0x24, 0x33, 0xf7, 0x76, 0x93, 0x68, 0x63,
	0x25, 0x53, 0x4f, 0x9c, 0x87, 0xe9, 0xa3, 0x2d, 0x38, 0xf4, 0x9b, 0x23, 0xcf, 0xf5, 0x27, 0x77,
	0x6f, 0x52, 0x0a, 0x05, 0xc9, 0x9e, 0xbf, 0xf2, 0x9c, 0xde, 0x61, 0xb3, 0xe1, 0x09, 0x27, 0xd8,
	0xdc, 0x96, 0xb5, 0x69, 0x35, 0x76, 0x2c, 0x38, 0x47, 0xc5, 0xaa, 0x62, 0x35, 0x84, 0x51, 0x82,
	0x88, 0xc6, 0xd8, 0x6c, 0x59, 0x37, 0x6b, 0x46, 0x09, 0xa2, 0x58, 0x71, 0x0d, 0xab, 0xdc, 0x10,
	0x45, 0xa3, 0x04, 0x31, 0xed, 0x01, 0x76, 0x5f, 0xbd, 0x51, 0x32, 0xcb, 0xa6, 0x51, 0x6a, 0xea,
	0x56, 0xa9, 0x39, 0xe9, 0x9a, 0x49, 0x7b, 0xec, 0x92, 0x62, 0x47, 0xb8, 0x8a, 0xc5, 0x52, 0xa1,
	0x1f, 0x43, 0x8f, 0xc9, 0x6a, 0xf6, 0xd2, 0x33, 0x7b, 0x4c, 0x24, 0x3b, 0x53, 0x94, 0x7e, 0x7b,
	0x84, 0x25, 0xf4, 0x7d, 0xaf, 0x1f, 0x54, 0x3d, 0xb7, 0x1b, 0x1c, 0x60, 0xb2, 0x1e, 0x0e, 0xd1,
	0x59, 0xd2, 0x7b, 0x11, 0xf2, 0x1e, 0x93, 0x22, 0x72, 0x5d, 0x83, 0xcd, 0xf9, 0xc7, 0x7e, 0xa7,
	0xbf, 0x37, 0x08, 0xb3, 0x74, 0xf5, 0xf4, 0x2f, 0xab, 0x13, 0xdd, 0x4b, 0xb6, 0x9c, 0x27, 0x93,
	0x61, 0xac, 0xe5, 0xc1, 0x27, 0x58, 0x72, 0xba, 0xe3, 0xac, 0xdf, 0x92, 0x14, 0xe6, 0xef, 0x9c,
	0x61, 0x0f, 0xdc, 0x21, 0xeb, 0xc2, 0xb3, 0xba, 0x6b, 0xe1, 0x69, 0xb3, 0xfb, 0xd4, 0xc2, 0xd3,
	0x9c, 0xa4, 0x01, 0xee, 0x6c, 0xf9, 0xec, 0xf5, 0x27, 0x3c, 0xdb, 0x4b, 0xfd, 0x3b, 0x98, 0x71,
	0x5b, 0xa1, 0x89, 0xdd, 0x5e, 0x68, 0xae, 0xb0, 0x78, 0xab, 0xdb, 0x09, 0xd3, 0x53, 0x16, 0xa2,
	0x79, 0x29, 0xa0, 0xc7, 0xe7, 0x42, 0xd8, 0xa9, 0xbe, 0x27, 0x53, 0x52, 0x3a, 0x7e, 0x4b, 0x6e,
	0xb1, 0x99, 0xe0, 0x78, 0xe8, 0x51, 0x3c, 0x2f, 0x64, 0xf5, 0x7b, 0x2d, 0x55, 0x4a, 0x42, 0x3b,
	0xc7, 0x43, 0x2c, 0xeb, 0xc7, 0x43, 0x0f, 0x5f, 0x91, 0xee, 0x7e, 0x68, 0x99, 0x7c, 0x7d, 0xcc,
	0x11, 0x9b, 0x6d, 0xfc, 0xa0, 0x92, 0x5d, 0xdd, 0xc1, 0xbe, 0xbf, 0x38, 0x4f, 0x35, 0x36, 0x4e,
	0x92, 0xda, 0x60, 0xdf, 0xd7, 0x36, 0x59, 0x52, 0x76, 0x1f, 0x90, 0xff, 0xe9, 0x99, 0x99, 0xc8,
	0x5e, 0x3f, 0x6b, 0xbc, 0x88, 0x84, 0x7b, 0x02, 0xe9, 0x6d, 0xc6, 0x4e, 0x4c, 0xc3, 0xa7, 0x4a,
	0x98, 0x6c, 0x4d, 0xdb, 0xd1, 0x9d, 0x2d, 0x1b, 0xce, 0x69, 0x17, 0x59, 0x8a, 0x37, 0x6a, 0x66,
	0xf1, 0xd6, 0x58, 0x14, 0xd1, 0x16, 0x18, 0xab, 0x35, 0x2a, 0x63, 0x8e, 0xe2, 0x90, 0xaa, 0xa1,
	0xd7, 0x9c, 0xea, 0x58, 0x14, 0x4b, 0xbf, 0x29, 0xc6, 0x12, 0x9b, 0xee, 0xde, 0xd3, 0xee, 0xd6,
	0xb0, 0xed, 0x06, 0xf8, 0xa5, 0x2f, 0x4f, 0x51, 0x3e, 0x5d, 0x4e, 0xff, 0xfc, 0x9c, 0x9a, 0xb7,
	0x24, 0xff, 0x4c, 0x9d, 0xdb, 0x35, 0x96, 0xf4, 0xbd, 0x67, 0x0e, 0xbd, 0x7e, 0xcb, 0x6b, 0xf6,
	0x0f, 0x7b, 0xe1, 0x27, 0x65, 0x62, 0x2c, 0xb3, 0x0e, 0x7b, 0x18, 0x7f, 0xe3, 0x00, 0x55, 0xef,
	0x3f, 0xf9, 0x22, 0x58, 0xbe, 0x57, 0x17, 0x8a, 0x4b, 0xc1, 0x1d, 0xee, 0xdf, 0x45, 0x36, 0x37,
	0x8e, 0x9b, 0x19, 0x4a, 0xe7, 0x31, 0x6a, 0xaf, 0xfa, 0xff, 0xe2, 0xff, 0x3c, 0xad, 0x9f, 0x7f,
	0xef, 0x42, 0xe8, 0x8e, 0x59, 0x90, 0x7e, 0x82, 0xb1, 0x93, 0x23, 0xc2, 0x67, 0xe5, 0x16, 0x2f,
	0xe9, 0x8e, 0x81, 0x8e, 0x10, 0x0e, 0x9c, 0xc3, 0x22, 0x29, 0x25, 0xd2, 0x6d, 0x61, 0xaf, 0x61,
	0x95, 0x20, 0x7a, 0x23, 0xcb, 0x2e, 0x3c, 0xe7, 0x9f, 0x62, 0xea, 0x6b, 0x70, 0x9e, 0xcd, 0x98,
	0xfc, 0x68, 0x45, 0x3e, 0x06, 0x4d, 0x7e, 0x94, 0x87, 0xe8, 0x8d, 0xd7, 0x3c, 0xc8, 0xd8, 0xc9,
	0x17, 0xb7, 0x36, 0xcb, 0xa2, 0x26, 0x0f, 0x87, 0x16, 0xeb, 0x3c, 0x1c, 0x5a, 0xa9, 0x73, 0x88,
	0x6a, 0x73, 0x2c, 0x56, 0xa9, 0x70, 0x88, 0xc9, 0xd9, 0x26, 0x87, 0x19, 0x1c, 0x6e, 0x3b, 0x70,
	0x1e, 0xbb, 0x9c, 0x22, 0x87, 0x59, 0x6c, 0x14, 0x0b, 0x0e, 0xcc, 0x61, 0xc3, 0xa8, 0x70, 0x98,
	0xc7, 0x86, 0x59, 0xe1, 0x10, 0x47, 0xcb, 0x0b, 0x05, 0x4b, 0x14, 0x8b, 0xc0, 0x50, 0x68, 0x6d,
	0x73, 0x48, 0x60, 0x83, 0x6f, 0x71, 0x48, 0xd2, 0x4b, 0x55, 0x54, 0xb6, 0x6c, 0x48, 0x61, 0xd3,
	0xa8, 0x17, 0x1b, 0x16, 0x2c, 0xe0, 0x4a, 0xbb, 0x96, 0xe1, 0xc0, 0x05, 0x14, 0x16, 0xab, 0x7a,
	0xc3, 0x06, 0xc0, 0x39, 0x5b, 0x25, 0x0e, 0x17, 0xb1, 0x51, 0xdf, 0xda, 0x05, 0x0d, 0x77, 0x59,
	0x2a, 0x5a, 0x75, 0x43, 0xb7, 0xe1, 0x12, 0x4a, 0xab, 0x75, 0x0e, 0x97, 0x49, 0xb7, 0xa8, 0xc3,
	0x7d, 0x64, 0x42, 0x89, 0xc3, 0xfd, 0x68, 0x82, 0x23, 0xb6, 0xac, 0xcd, 0x0c, 0xbc, 0x60, 0xd2,
	0xce, 0xc2, 0x22, 0x2a, 0xaf, 0x19, 0x7a, 0x39, 0x03, 0x0f, 0x8c, 0x9b, 0x59, 0x78, 0x10, 0xa7,
	0x89, 0x12, 0x87, 0x2b, 0xb4, 0x5f, 0xe1, 0x70, 0x78, 0x3f, 0xdc, 0xaf, 0xc3, 0xe1, 0x85, 0x38,
	0xd9, 0x32, 0x9c, 0x42, 0xcd, 0x81, 0x17, 0x61, 0xbb, 0x5e, 0xe6, 0x96, 0xcd, 0xe1, 0x21, 0xbc,
	0xb6, 0xea, 0x86, 0x30, 0x1d, 0xd3, 0xe2, 0x70, 0x15, 0x15, 0xd8, 0x06, 0x87, 0x6b, 0xa8, 0xa0,
	0x99, 0xe3, 0x45, 0x48, 0x93, 0xaa, 0x12, 0x17, 0xf0, 0x30, 0x76, 0xee, 0x3a, 0x1c, 0x5e, 0x8c,
	0x8d, 0x52, 0x89, 0xc3, 0x23, 0xd8, 0x57, 0xac, 0x3b, 0x1c, 0x1e, 0xc5, 0x96, 0xc3, 0x39, 0x87,
	0x97, 0x90, 0x3f, 0x6a, 0x70, 0x9d, 0xb6, 0xc0, 0xf3, 0xf0, 0x52, 0xec, 0xb2, 0x4b, 0x82, 0xc3,
	0x0d, 0xdc, 0xb4, 0x68, 0x6c, 0x39, 0xa6, 0x55, 0x81, 0x97, 0xe1, 0xc2, 0x65, 0xa1, 0x57, 0xea,
	0x86, 0xe5, 0xc0, 0x63, 0x38, 0x48, 0xd8, 0xdb, 0x1c, 0x96, 0xc8, 0x67, 0xc2, 0x80, 0xc7, 0x51,
	0x54, 0xaf, 0x0a, 0x0e, 0xcb, 0xe4, 0x19, 0x4b, 0x87, 0x0c, 0x35, 0x6c, 0x0e, 0x59, 0x5c, 0x44,
	0xaf, 0x42, 0x0e, 0xf7, 0x6e, 0x5a, 0x35, 0x9b, 0xc3, 0x0a, 0x36, 0xed, 0x1d, 0x93, 0x1b, 0xb0,
	0x8a, 0x33, 0x2d, 0x5d, 0x70, 0xc8, 0xd3, 0x4e, 0x1b, 0x05, 0xb3, 0x66, 0xc0, 0x1a, 0x99, 0x88,
	0x43, 0xd7, 0xc9, 0xa2, 0x4d, 0x93, 0xc3, 0x06, 0xcd, 0x2f, 0xd6, 0x79, 0x1e, 0x9e, 0xa0, 0x49,
	0x0d, 0xcb, 0x80, 0x0f, 0x20, 0xdf, 0xd8, 0x4e, 0x83, 0x3b, 0x36, 0x3c, 0x89, 0xa0, 0x5b, 0xb7,
	0xaa, 0x0d, 0xdb, 0x81, 0x97, 0xd3, 0x7e, 0xcb, 0x0e, 0x87, 0x0f, 0x44, 0xc5, 0xba, 0x75, 0x0b,
	0x1d, 0xfd, 0x41, 0xe4, 0xfd, 0x5d, 0xae, 0x6f, 0xc2, 0x07, 0xe3, 0x27, 0xd4, 0xa6, 0xb8, 0xc5,
	0x9d, 0x46, 0x4d, 0xb7, 0x40, 0x27, 0x7f, 0x6c, 0x97, 0xa0, 0x20, 0xe3, 0x8f, 0x17, 0xa1, 0x88,
	0x13, 0x4b, 0xa6, 0xed, 0x94, 0x6d, 0x28, 0x61, 0xdb, 0xd6, 0x9d, 0x7a, 0xc3, 0x02, 0x03, 0x47,
	0x6c, 0x9b, 0xb6, 0x0e, 0x65, 0x39, 0xb6, 0xb8, 0x0d, 0x15, 0x5a, 0x8e, 0x5b, 0xbb, 0x50, 0x95,
	0xad, 0x6a, 0x01, 0x4c, 0x54, 0xb9, 0x63, 0x5b, 0xf0, 0x0a, 0x8a, 0x95, 0x6d, 0x0e, 0x9b, 0x78,
	0x90, 0x05, 0x11, 0xea, 0xa9, 0xd1, 0x31, 0x6c, 0x59, 0x56, 0x09, 0xea, 0xd8, 0xdc, 0x29, 0xa0,
	0xd4, 0xc2, 0x5d, 0xec, 0x14, 0xa4, 0x91, 0x0d, 0x3a, 0xc5, 0x86, 0x05, 0x9c, 0xd6, 0x44, 0xf7,
	0xdd, 0xa4, 0x59, 0xd4, 0x14, 0xd8, 0xdc, 0x36, 0x2d, 0xc3, 0x06, 0x9b, 0x72, 0xc4, 0xe1, 0xe0,
	0x50, 0xf0, 0xd8, 0x65, 0x4c, 0x8a, 0x2d, 0x72, 0x7e, 0x85, 0xc3, 0xb6, 0xcc, 0xa0, 0x32, 0xec,
	0xd0, 0xfe, 0xcd, 0x8a, 0xe0, 0xb0, 0x8b, 0x1a, 0x1b, 0x36, 0x2f, 0xc3, 0x2d, 0x3c, 0x09, 0x9b,
	0x0b, 0xd3, 0x31, 0x04, 0x2f, 0xc2, 0x87, 0x60, 0x47, 0x0d, 0x5d, 0xf2, 0x4a, 0x4a, 0x01, 0x87,
	0xc3, 0x87, 0xa2, 0x48, 0xdf, 0xcd, 0xae, 0xc2, 0x87, 0xe1, 0x58, 0xcc, 0x4e, 0xc3, 0x2a, 0xea,
	0x1c, 0x3e, 0x9c, 0x1c, 0x6f, 0x16, 0x39, 0x34, 0xc9, 0xac, 0x62, 0xd1, 0xe6, 0xf0, 0x11, 0xb8,
	0x03, 0xc3, 0xa9, 0x1a, 0xc2, 0xe4, 0xe0, 0xd2, 0x8a, 0x34, 0xf8, 0xa9, 0xd0, 0x11, 0x86, 0x55,
	0x84, 0x16, 0x4e, 0xac, 0xa0, 0xee, 0x36, 0x9d, 0x61, 0xb9, 0xce, 0xc1, 0xc3, 0x16, 0xb7, 0x2c,
	0x13, 0xf6, 0xe8, 0xc0, 0xcc, 0x3a, 0xec, 0xd3, 0xc2, 0xc2, 0xb4, 0xe1, 0x80, 0x02, 0xa1, 0xc8,
	0x6d, 0xe8, 0x60, 0xe7, 0x4d, 0x6b, 0x17, 0x5e, 0x45, 0x91, 0x65, 0xc1, 0xd3, 0xa8, 0xd7, 0xe4,
	0xc5, 0x46, 0x9d, 0x43, 0x97, 0xb2, 0xc2, 0xe2, 0xd0, 0xc3, 0xf2, 0x85, 0x22, 0xfd, 0x26, 0x37,
	0x0c, 0x01, 0x7d, 0x0a, 0x1f, 0xbe, 0x6b, 0x72, 0x18, 0xd0, 0x59, 0x0a, 0xc1, 0x61, 0x48, 0xeb,
	0x54, 0xea, 0xf0, 0x4c, 0x18, 0x3a, 0xcb, 0xd5, 0x06, 0x87, 0x11, 0x1d, 0x40, 0xd6, 0xe1, 0xe0,
	0xcb, 0xec, 0xd9, 0x85, 0x80, 0x8c, 0xd4, 0x1d, 0x0e, 0x87, 0xb4, 0x80, 0xc3, 0xe1, 0x88, 0x1a,
	0x82, 0xc3, 0xb3, 0x54, 0x31, 0x1c, 0x13, 0x5e, 0x4d, 0x92, 0x3a, 0x87, 0x63, 0x2a, 0x5c, 0x75,
	0xf8, 0x48, 0x52, 0xef, 0x70, 0xf8, 0x28, 0x9a, 0x6e, 0x9b, 0x36, 0x7c, 0x34, 0xb6, 0xf0, 0xc3,
	0x1d, 0x3e, 0x86, 0xe2, 0x04, 0xf3, 0xfe, 0x63, 0xa9, 0xfa, 0x08, 0x2c, 0x3a, 0x1f, 0xa7, 0xa5,
	0xd8, 0xbc, 0x6d, 0x17, 0x1b, 0xbc, 0x5e, 0x34, 0xe0, 0xe3, 0x23, 0x5a, 0x1c, 0xe3, 0xab, 0xe6,
	0xc0, 0x27, 0x60, 0xa5, 0x8c, 0xd9, 0xdc, 0x86, 0x4f, 0x24, 0x21, 0x7a, 0x00, 0x3e, 0x89, 0x9a,
	0x76, 0xd1, 0xe1, 0xf0, 0xc9, 0x11, 0x6d, 0x8e, 0x45, 0xcb, 0x45, 0xf8, 0x94, 0x88, 0x96, 0x64,
	0x73, 0x98, 0x9e, 0x66, 0xc5, 0x82, 0xd7, 0x44, 0xb4, 0x4b, 0x6c, 0x81, 0xb2, 0xca, 0x74, 0x6e,
	0x55, 0x0d, 0xbd, 0x64, 0x08, 0x78, 0x2d, 0x0d, 0xd9, 0x2a, 0xf1, 0x9a, 0xe9, 0x18, 0xf0, 0xba,
	0x08, 0xae, 0x59, 0xe7, 0x35, 0xdb, 0xb4, 0x4c, 0x0e, 0xaf, 0xc7, 0x87, 0xf2, 0xf9, 0xba, 0x8e,
	0xd9, 0xf2, 0x06, 0x5a, 0xb4, 0x6a, 0x72, 0xf8, 0x54, 0x92, 0xda, 0x55, 0xb3, 0x9e, 0x87, 0x4f,
	0xa3, 0x55, 0x77, 0x30, 0xb7, 0x3f, 0x9d, 0x9a, 0xa2, 0x51, 0x2d, 0xc2, 0x67, 0xe0, 0x7d, 0x11,
	0xe7, 0xa2, 0xe1, 0x34, 0x9a, 0x99, 0x95, 0x1c, 0x7c, 0xa6, 0xc2, 0x2b, 0xf0, 0x59, 0x0a, 0xaf,
	0xc2, 0x67, 0x2b, 0x9c, 0x87, 0xcf, 0x51, 0x78, 0x0d, 0x3e, 0x57, 0xe1, 0x75, 0xf8, 0x3c, 0x85,
	0x37, 0xe0, 0xf3, 0xa7, 0x79, 0x75, 0x19, 0xbe, 0x40, 0xe1, 0x0c, 0x7c, 0xa1, 0xc2, 0x59, 0xf8,
	0x22, 0x85, 0x73, 0xf0, 0xc5, 0x0a, 0xaf, 0xc0, 0x97, 0x28, 0xbc, 0x0a, 0x5f, 0xaa, 0x70, 0x1e,
	0xbe, 0x4c, 0xe1, 0x35, 0xf8, 0x72, 0x85, 0xd7, 0xe1, 0x2b, 0x14, 0xde, 0x80, 0xaf, 0x9c, 0xe6,
	0xfc, 0x32, 0xbc, 0x51, 0xe1, 0x0c, 0xbc, 0x49, 0xe1, 0x2c, 0x7c, 0x95, 0xc2, 0x39, 0xf8, 0x6a,
	0x85, 0x57, 0xe0, 0xcd, 0x0a, 0xaf, 0xc2, 0x5b, 0x14, 0xce, 0xc3, 0xd7, 0x28, 0xbc, 0x06, 0x5f,
	0xab, 0xf0, 0x3a, 0x7c, 0x9d, 0xc2, 0x1b, 0xf0, 0xf5, 0xd3, 0xbc, 0xb6, 0x0c, 0xdf, 0xa0, 0x70,
	0x06, 0xbe, 0x51, 0xe1, 0x2c, 0xbc, 0x55, 0xe1, 0x1c, 0x7c, 0x93, 0xc2, 0x2b, 0xf0, 0xcd, 0x0a,
	0xaf, 0xc2, 0xb7, 0x28, 0x9c, 0x87, 0x6f, 0x55, 0x78, 0x0d, 0xbe, 0x4d, 0xe1, 0x75, 0xf8, 0x76,
	0x85, 0x37, 0xe0, 0x3b, 0xa6, 0x79, 0x7d, 0x19, 0xbe, 0x53, 0xe1, 0x0c, 0x7c, 0x97, 0xc2, 0x59,
	0x78, 0x9b, 0xc2, 0x39, 0xf8, 0x6e, 0x85, 0x57, 0xe0, 0x7b, 0x14, 0x5e, 0x85, 0xef, 0x55, 0x38,
	0x0f, 0xdf, 0xa7, 0xf0, 0x1a, 0xbc, 0x5d, 0xe1, 0x75, 0xf8, 0x7e, 0x85, 0x37, 0xe0, 0x07, 0xa6,
	0x79, 0x63, 0x19, 0x7e, 0x50, 0xe1, 0x0c, 0xbc, 0x43, 0xe1, 0x2c, 0xbc, 0x53, 0xe1, 0x1c, 0xfc,
	0x90, 0xc2, 0x2b, 0xf0, 0xc3, 0x0a, 0xaf, 0xc2, 0x8f, 0x28, 0x9c, 0x87, 0x1f, 0x55, 0x78, 0x0d,
	0x7e, 0x4c, 0xe1, 0x75, 0xf8, 0x71, 0x85, 0x37, 0xe0, 0x27, 0xa6, 0x38, 0xbb, 0xbc, 0x0c, 0x3f,
	0xa9, 0x70, 0x06, 0x7e, 0x4a, 0xe1, 0x2c, 0xfc, 0xb4, 0xc2, 0x39, 0xf8, 0x19, 0x85, 0x57, 0xe0,
	0x67, 0x15, 0x5e, 0x85, 0x9f, 0x53, 0x38, 0x0f, 0x3f, 0xaf, 0xf0, 0x1a, 0xfc, 0x82, 0xc2, 0xeb,
	0xf0, 0x8b, 0x0a, 0x6f, 0xc0, 0x2f, 0x4d, 0x73, 0x66, 0x19, 0x7e, 0x59, 0xe1, 0x0c, 0xfc, 0x8a,
	0xc2, 0x59, 0xf8, 0x55, 0x85, 0x73, 0xf0, 0x6b, 0x0a, 0xaf, 0xc0, 0xaf, 0x2b, 0xbc, 0x0a, 0xbf,
	0xa1, 0x70, 0x1e, 0x7e, 0x53, 0xe1, 0x35, 0x78, 0x97, 0xc2, 0xeb, 0xf0, 0x5b, 0x0a, 0x6f, 0xc0,
	0x6f, 0x4f, 0x73, 0x76, 0x19, 0xde, 0xad, 0x70, 0x06, 0x7e, 0x47, 0xe1, 0x2c, 0xfc, 0xae, 0xc2,
	0x39, 0xf8, 0x3d, 0x85, 0x57, 0xe0, 0xf7, 0x15, 0x5e, 0x85, 0x3f, 0x50, 0x38, 0x0f, 0x7f, 0xa8,
	0xf0, 0x1a, 0xfc, 0x91, 0xc2, 0xeb, 0xf0, 0xc7, 0x0a, 0x6f, 0xc0, 0x9f, 0x4c, 0x73, 0x6e, 0x19,
	0xfe, 0x54, 0xe1, 0x0c, 0xfc, 0x99, 0xc2, 0x59, 0xf8, 0x73, 0x85, 0x73, 0xf0, 0x17, 0x0a, 0xaf,
	0xc0, 0x5f, 0x2a, 0xbc, 0x0a, 0x7f, 0xa5, 0x70, 0x1e, 0xfe, 0x5a, 0xe1, 0x35, 0xf8, 0x1b, 0x85,
	0xd7, 0xe1, 0x6f, 0x15, 0xde, 0x80, 0xbf, 0x9b, 0xe6, 0x95, 0x65, 0xf8, 0x7b, 0x85, 0x33, 0xf0,
	0x0f, 0x0a, 0x67, 0xe1, 0x3d, 0x0a, 0xe7, 0xe0, 0x1f, 0x15, 0x5e, 0x81, 0x7f, 0x52, 0x78, 0x15,
	0xfe, 0x59, 0xe1, 0x3c, 0xfc, 0x0b, 0xdd, 0x74, 0xba, 0xe0, 0x4d, 0x61, 0x6c, 0x0b, 0xe3, 0xe6,
	0x96, 0x61, 0x3b, 0xf0, 0xaf, 0x11, 0xed, 0x22, 0x4b, 0x4e, 0x84, 0xbc, 0x76, 0x0b, 0xfe, 0x2d,
	0xa2, 0x01, 0x4b, 0x48, 0x91, 0x1c, 0xf4, 0xef, 0xa4, 0x49, 0x4a, 0x70, 0xc4, 0x7f, 0x4c, 0x6b,
	0x5e, 0xcd, 0xc0, 0x7f, 0x2a, 0x9c, 0x85, 0xff, 0x22, 0x0d, 0xc6, 0x2e, 0x37, 0x84, 0x89, 0x0f,
	0xe2, 0x0c, 0xfc, 0xf7, 0x73, 0x24, 0x59, 0xf8, 0x1f, 0xba, 0x54, 0x85, 0x61, 0x1b, 0x62, 0xdb,
	0x28, 0xc1, 0xff, 0x46, 0x0a, 0x9b, 0xec, 0xb1, 0xd6, 0xa0, 0xb7, 0x34, 0xf9, 0x01, 0xc7, 0xd2,
	0xe9, 0x3f, 0xe5, 0x28, 0x9c, 0xf6, 0x53, 0x8e, 0xa7, 0x66, 0x69, 0x4c, 0xee, 0xff, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x74, 0xad, 0xb5, 0x63, 0x16, 0x22, 0x00, 0x00,
}
